#!/usr/bin/env node

import { readFileSync, writeFileSync, readdirSync, existsSync } from 'fs';
import { join, parse, dirname, relative } from 'path';
import { homedir, platform } from 'os';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Get VS Code User profile directory based on platform
const getVSCodeUserDir = () => {
    const home = homedir();
    const plat = platform();
    
    switch (plat) {
        case 'darwin': // macOS
            return join(home, 'Library', 'Application Support', 'Code', 'User');
        case 'win32': // Windows
            return join(home, 'AppData', 'Roaming', 'Code', 'User');
        case 'linux': // Linux
            return join(home, '.config', 'Code', 'User');
        default:
            // Fallback to Linux path for unknown platforms
            return join(home, '.config', 'Code', 'User');
    }
};

// Detect project root (where .agents directory exists)
const findProjectRoot = () => {
    let currentDir = process.cwd();
    const root = parse(currentDir).root;
    
    while (currentDir !== root) {
        if (existsSync(join(currentDir, '.agents'))) {
            return currentDir;
        }
        currentDir = dirname(currentDir);
    }
    
    return process.cwd();
};

// Paths configuration
const paths = {
    home: homedir(),
    vscodeUserDir: getVSCodeUserDir(),
    projectRoot: findProjectRoot(),
    get projectClaudeSkills() { return join(this.projectRoot, '.claude', 'skills'); },
    get projectAgentsSkills() { return join(this.projectRoot, '.agents', 'skills'); },
    get homePersonalSkills() { return join(this.home, '.agents', 'skills'); },
    get bootstrap() { return join(this.projectRoot, '.agents', 'superpowers-bootstrap.md'); },
    get superpowersRepo() { 
        // If running from the superpowers repo itself, use current location
        // Otherwise use installed location
        const currentRepoCheck = join(__dirname, '..', 'skills');
        if (existsSync(currentRepoCheck) && existsSync(join(__dirname, '..', '.github', 'prompts'))) {
            return join(__dirname, '..');
        }
        return join(this.home, '.agents', 'superpowers');
    },
    get homeSuperpowersSkills() { return join(this.superpowersRepo, 'skills'); }
};

// Utility functions
const getDefaultConfig = () => ({
    auto_update: true,
    last_update_check: null,
    last_updated_commit: null
});

const readConfig = () => {
    const configPath = join(paths.superpowersRepo, '.config.json');
    try {
        if (!existsSync(configPath)) {
            return getDefaultConfig();
        }
        const content = readFileSync(configPath, 'utf8');
        return { ...getDefaultConfig(), ...JSON.parse(content) };
    } catch {
        return getDefaultConfig();
    }
};

const writeConfig = (updates) => {
    const configPath = join(paths.superpowersRepo, '.config.json');
    const current = readConfig();
    const updated = { ...current, ...updates };
    try {
        writeFileSync(configPath, JSON.stringify(updated, null, 2));
    } catch (error) {
        console.log(`Warning: couldn't save config: ${error.message}`);
    }
};

const isRepoClean = () => {
    try {
        const output = execSync('git status --porcelain', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe',
            timeout: 3000
        });
        return output.trim().length === 0;
    } catch {
        return false;
    }
};

const isOnMainBranch = () => {
    try {
        const branch = execSync('git rev-parse --abbrev-ref HEAD', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe',
            timeout: 3000
        });
        return branch.trim() === 'main';
    } catch {
        return false;
    }
};

const checkForUpdates = () => {
    try {
        // Fetch latest from origin
        execSync('git fetch origin', {
            cwd: paths.superpowersRepo,
            timeout: 5000,
            stdio: 'pipe'
        });

        // Check if repo is clean
        const hasLocalChanges = !isRepoClean();

        // Get current and latest commits
        const currentCommit = execSync('git rev-parse HEAD', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();

        const latestCommit = execSync('git rev-parse origin/main', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();

        const hasUpdates = currentCommit !== latestCommit;

        if (!hasUpdates) {
            return {
                hasUpdates: false,
                hasLocalChanges,
                currentCommit,
                latestCommit,
                commitsBehind: 0,
                changedFiles: []
            };
        }

        // Count commits behind
        const commitsBehind = parseInt(execSync('git rev-list --count HEAD..origin/main', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim(), 10);

        // Get changed files
        const changedFilesOutput = execSync('git diff --name-only HEAD origin/main', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        });

        const changedFiles = changedFilesOutput.trim().split('\n').filter(f => f.length > 0);

        return {
            hasUpdates: true,
            hasLocalChanges,
            currentCommit,
            latestCommit,
            commitsBehind,
            changedFiles
        };
    } catch {
        return {
            hasUpdates: false,
            hasLocalChanges: false,
            currentCommit: '',
            latestCommit: '',
            commitsBehind: 0,
            changedFiles: [],
            error: true
        };
    }
};

const determineReinstalls = (changedFiles) => {
    const integrationMap = {
        '.github/prompts/': 'copilot-prompts',
        '.github/copilot-instructions.md': 'copilot-instructions',
        '.cursor/commands/': 'cursor-commands',
        'hooks/cursor/': 'cursor-hooks',
        '.codex/prompts/': 'codex-prompts',
        '.gemini/commands/': 'gemini-commands',
        'commands/': 'claude-commands',
        '.opencode/command/': 'opencode-commands'
    };
    
    const toReinstall = new Set();
    
    for (const file of changedFiles) {
        for (const [pathPrefix, integration] of Object.entries(integrationMap)) {
            if (file.startsWith(pathPrefix)) {
                toReinstall.add(integration);
            }
        }
    }
    
    return Array.from(toReinstall);
};

const reinstallIntegration = (integration) => {
    const installFunctions = {
        'copilot-prompts': installCopilotPrompts,
        'copilot-instructions': installCopilotInstructions,
        'cursor-commands': installCursorCommands,
        'cursor-hooks': installCursorHooks,
        'codex-prompts': installCodexPrompts,
        'gemini-commands': installGeminiCommands,
        'claude-commands': installClaudeCommands,
        'opencode-commands': installOpencodeCommands
    };
    
    const installFn = installFunctions[integration];
    if (installFn) {
        try {
            installFn();
            return { success: true, integration };
        } catch (error) {
            return { success: false, integration, error: error.message };
        }
    }
    return { success: false, integration, error: 'Unknown integration' };
};

const detectTool = (command) => {
    try {
        execSync(`which ${command}`, { 
            stdio: 'pipe',
            timeout: 2000 
        });
        return true;
    } catch {
        return false;
    }
};

const toolDetection = {
    opencode: { 
        check: () => detectTool('opencode'), 
        cli: true,
        name: 'OpenCode',
        installUrl: 'https://opencode.ai/docs/installation',
        bootstrapCommand: 'install-opencode-commands'
    },
    claude: { 
        check: () => detectTool('claude'), 
        cli: true,
        name: 'Claude Code',
        installUrl: 'https://code.claude.com/docs/en/installation',
        bootstrapCommand: 'install-claude-commands'
    },
    gemini: { 
        check: () => detectTool('gemini'), 
        cli: true,
        name: 'Gemini',
        installUrl: 'https://cloud.google.com/gemini/docs/cli/install',
        bootstrapCommand: 'install-gemini-commands'
    },
    codex: { 
        check: () => detectTool('codex'), 
        cli: true,
        name: 'Codex',
        installUrl: 'https://developers.openai.com/codex/docs/installation',
        bootstrapCommand: 'install-codex-prompts'
    },
    cursor: { 
        check: () => true, 
        cli: false,
        name: 'Cursor',
        bootstrapCommand: 'install-cursor-commands'
    },
    copilot: { 
        check: () => true, 
        cli: false,
        name: 'GitHub Copilot',
        bootstrapCommand: 'install-copilot-prompts'
    }
};

const extractFrontmatter = (filePath) => {
    try {
        const content = readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        const frontmatter = { name: '', description: '', whenToUse: '' };
        let inFrontmatter = false;

        for (const line of lines) {
            if (line.trim() === '---') {
                if (inFrontmatter) break;
                inFrontmatter = true;
                continue;
            }

            if (inFrontmatter) {
                const match = line.match(/^(\w+):\s*(.*)$/);
                if (match) {
                    const [, key, value] = match;
                    const fieldMap = {
                        'name': 'name',
                        'description': 'description',
                        'when_to_use': 'whenToUse'
                    };
                    if (fieldMap[key]) {
                        frontmatter[fieldMap[key]] = value.trim();
                    }
                }
            }
        }

        return frontmatter;
    } catch {
        return { name: '', description: '', whenToUse: '' };
    }
};

const skillTypes = {
    claude: { dir: 'projectClaudeSkills', prefix: 'claude:' },
    project: { dir: 'projectAgentsSkills', prefix: '' },
    personal: { dir: 'homePersonalSkills', prefix: '' },
    superpowers: { dir: 'homeSuperpowersSkills', prefix: 'superpowers:' }
};

const printSkill = (skillPath, sourceType) => {
    const skillFile = join(skillPath, 'SKILL.md');
    const { dir, prefix } = skillTypes[sourceType];
    const relPath = relative(paths[dir], skillPath).replace(/\\/g, '/');
    
    console.log(`${prefix}${relPath}`);
    
    const { description, whenToUse } = extractFrontmatter(skillFile);
    if (description) console.log(`  ${description}`);
    if (whenToUse) console.log(`  When to use: ${whenToUse}`);
    console.log('');
};

const findSkillsInDir = (dir, sourceType, maxDepth = 1) => {
    const skills = [];
    if (!existsSync(dir)) return skills;

    const searchDir = (currentDir, currentDepth) => {
        if (currentDepth > maxDepth) return;

        try {
            const entries = readdirSync(currentDir, { withFileTypes: true });

            for (const entry of entries) {
                if (!entry.isDirectory()) continue;
                
                const skillDir = join(currentDir, entry.name);
                const skillFile = join(skillDir, 'SKILL.md');

                if (existsSync(skillFile)) {
                    skills.push(skillDir);
                }

                if (currentDepth < maxDepth) {
                    searchDir(skillDir, currentDepth + 1);
                }
            }
        } catch {
            // Ignore permission errors
        }
    };

    searchDir(dir, 0);
    return skills;
};

// Commands
const runFindSkills = () => {
    console.log('Available skills:');
    console.log('==================');
    console.log('');

    const foundSkills = new Set();
    
    // Skill discovery order (priority: project > claude > personal > superpowers)
    const discoveryOrder = [
        { type: 'project', dir: paths.projectAgentsSkills, maxDepth: 2 },
        { type: 'claude', dir: paths.projectClaudeSkills, maxDepth: 2 },
        { type: 'personal', dir: paths.homePersonalSkills, maxDepth: 2 },
        { type: 'superpowers', dir: paths.homeSuperpowersSkills, maxDepth: 1 }
    ];

    for (const { type, dir, maxDepth } of discoveryOrder) {
        const skills = findSkillsInDir(dir, type, maxDepth);
        for (const skillPath of skills) {
            const relPath = relative(dir, skillPath);
            if (!foundSkills.has(relPath)) {
                foundSkills.add(relPath);
                printSkill(skillPath, type);
            }
        }
    }

    console.log('Usage:');
    console.log('  .agents/superpowers-agent use-skill <skill-name>   # Load a specific skill');
    console.log('');
    console.log('Skill naming:');
    console.log('  Project skills: skill-name (from .agents/skills/ - highest priority)');
    console.log('  Claude skills: claude:skill-name (from .claude/skills/)');
    console.log('  Personal skills: skill-name (from ~/.agents/skills/)');
    console.log('  Superpowers skills: superpowers:skill-name (from ~/.agents/superpowers/skills/)');
    console.log('');
    console.log('Priority: .agents/skills > .claude/skills > ~/.agents/skills > ~/.agents/superpowers/skills');
    console.log('Note: All skills are disclosed at session start via bootstrap.');
};

const installCopilotPrompts = () => {
    const promptsSourceDir = join(paths.superpowersRepo, '.github', 'prompts');
    const promptsDestDir = join(paths.vscodeUserDir, 'prompts');
    
    if (!existsSync(promptsSourceDir)) {
        console.log('‚ö†Ô∏è  No Copilot prompts to install (source directory not found).');
        return;
    }
    
    // Create destination directory
    try {
        if (!existsSync(promptsDestDir)) {
            execSync(`mkdir -p "${promptsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating prompts directory: ${error.message}`);
        return;
    }
    
    // Copy all .prompt.md files
    let promptFiles;
    try {
        promptFiles = readdirSync(promptsSourceDir)
            .filter(f => f.endsWith('.prompt.md'));
    } catch (error) {
        console.log(`Error reading prompts directory: ${error.message}`);
        return;
    }
    
    if (promptFiles.length === 0) {
        console.log('‚ö†Ô∏è  No prompt files found to install.');
        return;
    }
    
    console.log('Installing GitHub Copilot prompts...');
    let installed = 0;
    for (const file of promptFiles) {
        try {
            const source = join(promptsSourceDir, file);
            const dest = join(promptsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }
    
    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} prompt(s) to ${promptsDestDir}`);
        console.log('  Use slash commands in GitHub Copilot:');
        console.log('    /brainstorm-with-superpowers - Refine ideas into designs');
        console.log('    /write-a-skill - Create new skills with TDD');
        console.log('    /skills - Discover available skills');
        console.log('    /use-skill - Load and apply a specific skill');
    }
};

const installCopilotInstructions = () => {
    const instructionsSource = join(paths.superpowersRepo, '.github', 'copilot-instructions.md');
    const instructionsDest = join(paths.home, '.github', 'copilot-instructions.md');
    
    if (!existsSync(instructionsSource)) {
        console.log('‚ö†Ô∏è  No Copilot instructions to install (source file not found).');
        return;
    }
    
    // Create destination directory
    const destDir = dirname(instructionsDest);
    try {
        if (!existsSync(destDir)) {
            execSync(`mkdir -p "${destDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating .github directory: ${error.message}`);
        return;
    }
    
    // Copy instructions
    try {
        execSync(`cp "${instructionsSource}" "${instructionsDest}"`, { stdio: 'pipe' });
        console.log('‚úì Installed GitHub Copilot universal instructions');
        console.log(`  Location: ${instructionsDest}`);
        console.log('  GitHub Copilot will now use Superpowers skills universally in all workspaces');
    } catch (error) {
        console.log(`‚úó Failed to install instructions: ${error.message}`);
    }
};

const installCursorCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, '.cursor', 'commands');
    const commandsDestDir = join(paths.home, '.cursor', 'commands');
    
    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No Cursor commands to install (source directory not found).');
        return;
    }
    
    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Cursor commands directory: ${error.message}`);
        return;
    }
    
    // Copy all .md files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading Cursor commands directory: ${error.message}`);
        return;
    }
    
    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }
    
    console.log('Installing Cursor commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }
    
    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}`);
        console.log('  Use slash commands in Cursor:');
        console.log('    /brainstorm-with-superpowers - Refine ideas into designs');
        console.log('    /write-a-skill - Create new skills with TDD');
        console.log('    /skills - Discover available skills');
        console.log('    /use-skill - Load and apply a specific skill');
    }
};

const installCursorHooks = () => {
    const hooksSourceDir = join(paths.superpowersRepo, 'hooks', 'cursor');
    const hooksDestDir = join(paths.home, '.cursor', 'hooks');
    const hooksJsonSource = join(hooksSourceDir, 'hooks.json');
    const hooksJsonDest = join(paths.home, '.cursor', 'hooks.json');

    if (!existsSync(hooksSourceDir)) {
        console.log('‚ö†Ô∏è  No Cursor hooks to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(hooksDestDir)) {
            execSync(`mkdir -p "${hooksDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Cursor hooks directory: ${error.message}`);
        return;
    }

    // Copy hooks.json
    try {
        execSync(`cp "${hooksJsonSource}" "${hooksJsonDest}"`, { stdio: 'pipe' });
        console.log('  ‚úì Installed hooks.json');
    } catch (error) {
        console.log(`  ‚úó Failed to install hooks.json: ${error.message}`);
        return;
    }

    // Copy hook scripts
    let hookFiles;
    try {
        hookFiles = readdirSync(hooksSourceDir)
            .filter(f => f.endsWith('.sh'));
    } catch (error) {
        console.log(`Error reading hooks directory: ${error.message}`);
        return;
    }

    if (hookFiles.length === 0) {
        console.log('‚ö†Ô∏è  No hook scripts found to install.');
        return;
    }

    console.log('Installing Cursor hooks...');
    let installed = 0;
    for (const file of hookFiles) {
        try {
            const source = join(hooksSourceDir, file);
            const dest = join(hooksDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            execSync(`chmod +x "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} hook(s) to ${hooksDestDir}`);
        console.log('  Cursor will now auto-bootstrap skills at conversation start');
        console.log('  Restart Cursor for hooks to take effect');
    }
};

const installCodexPrompts = () => {
    const promptsSourceDir = join(paths.superpowersRepo, '.codex', 'prompts');
    const promptsDestDir = join(paths.home, '.codex', 'prompts');

    if (!existsSync(promptsSourceDir)) {
        console.log('‚ö†Ô∏è  No Codex prompts to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(promptsDestDir)) {
            execSync(`mkdir -p "${promptsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Codex prompts directory: ${error.message}`);
        return;
    }

    // Copy all .md files
    let promptFiles;
    try {
        promptFiles = readdirSync(promptsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading Codex prompts directory: ${error.message}`);
        return;
    }

    if (promptFiles.length === 0) {
        console.log('‚ö†Ô∏è  No prompt files found to install.');
        return;
    }

    console.log('Installing OpenAI Codex prompts...');
    let installed = 0;
    for (const file of promptFiles) {
        try {
            const source = join(promptsSourceDir, file);
            const dest = join(promptsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} prompt(s) to ${promptsDestDir}`);
        console.log('  Use slash commands in OpenAI Codex:');
        console.log('    /prompts:brainstorm - Refine ideas into designs');
        console.log('    /prompts:write-skill - Create new skills with TDD');
        console.log('    /prompts:skills - Discover available skills');
        console.log('    /prompts:use-skill - Load and apply a specific skill');
        console.log('  Note: Restart Codex or open a new session to reload prompts');
    }
};

const installGeminiCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, '.gemini', 'commands');
    const commandsDestDir = join(paths.home, '.gemini', 'commands');

    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No Gemini commands to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Gemini commands directory: ${error.message}`);
        return;
    }

    // Copy all .toml files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.toml'));
    } catch (error) {
        console.log(`Error reading Gemini commands directory: ${error.message}`);
        return;
    }

    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }

    console.log('Installing Gemini commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}`);
        console.log('  Use slash commands in Gemini:');
        console.log('    /brainstorm-with-superpowers - Refine ideas into designs');
        console.log('    /write-a-skill - Create new skills with TDD');
        console.log('    /skills - Discover available skills');
        console.log('    /use-skill - Load and apply a specific skill');
    }
};

const installClaudeCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, 'commands');
    const commandsDestDir = join(paths.home, '.claude', 'commands');

    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No Claude commands to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Claude commands directory: ${error.message}`);
        return;
    }

    // Copy all .md files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading Claude commands directory: ${error.message}`);
        return;
    }

    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }

    console.log('Installing Claude Code commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}`);
        console.log('  Use slash commands in Claude Code:');
        console.log('    /brainstorm - Refine ideas into designs');
        console.log('    /execute-plan - Execute plans in batches');
        console.log('    /write-plan - Create implementation plans');
        console.log('    /skills - Discover available skills');
        console.log('    /use-skill - Load and apply a specific skill');
    }
};

const installOpencodeCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, '.opencode', 'command');
    const commandsDestDir = join(paths.home, '.config', 'opencode', 'command');

    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No opencode commands to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating opencode commands directory: ${error.message}`);
        return;
    }

    // Copy all .md files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading opencode commands directory: ${error.message}`);
        return;
    }

    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }

    console.log('Installing opencode commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}`);
        console.log('  Use slash commands in opencode:');
        console.log('    /brainstorm - Refine ideas into designs');
        console.log('    /execute-plan - Execute plans in batches');
        console.log('    /write-plan - Create implementation plans');
        console.log('    /write-skill - Create new skills with TDD');
        console.log('    /skills - Discover available skills');
        console.log('    /use-skill - Load and apply a specific skill');
    }
};

const runSetupSkills = () => {
    console.log('# Setting up Superpowers skills for this project');
    console.log('');

    const projectRoot = paths.projectRoot;
    const agentsDir = join(projectRoot, '.agents');
    const skillsDir = join(agentsDir, 'skills');
    const agentsMdPath = join(agentsDir, 'AGENTS.md');
    const templatePath = join(paths.superpowersRepo, '.agents', 'templates', 'AGENTS.md.template');

    // Check if template exists
    if (!existsSync(templatePath)) {
        console.log('‚úó Error: AGENTS.md template not found');
        console.log(`  Expected: ${templatePath}`);
        console.log('  Please update your Superpowers installation');
        return;
    }

    // Create .agents directory
    if (!existsSync(agentsDir)) {
        try {
            execSync(`mkdir -p "${agentsDir}"`, { stdio: 'pipe' });
            console.log('‚úì Created .agents/ directory');
        } catch (error) {
            console.log(`‚úó Failed to create .agents/ directory: ${error.message}`);
            return;
        }
    } else {
        console.log('‚úì .agents/ directory exists');
    }

    // Create skills directory
    if (!existsSync(skillsDir)) {
        try {
            execSync(`mkdir -p "${skillsDir}"`, { stdio: 'pipe' });
            execSync(`touch "${join(skillsDir, '.gitkeep')}"`, { stdio: 'pipe' });
            console.log('‚úì Created .agents/skills/ directory');
        } catch (error) {
            console.log(`‚úó Failed to create skills directory: ${error.message}`);
            return;
        }
    } else {
        console.log('‚úì .agents/skills/ directory exists');
    }

    // Handle existing AGENTS.md
    if (existsSync(agentsMdPath)) {
        const timestamp = new Date().toISOString().split('T')[0];
        const backupPath = `${agentsMdPath}.backup-${timestamp}`;
        try {
            execSync(`cp "${agentsMdPath}" "${backupPath}"`, { stdio: 'pipe' });
            console.log(`‚úì Backed up existing AGENTS.md to ${parse(backupPath).base}`);
        } catch (error) {
            console.log(`‚úó Failed to backup AGENTS.md: ${error.message}`);
            return;
        }
    }

    // Read template
    let template;
    try {
        template = readFileSync(templatePath, 'utf8');
    } catch (error) {
        console.log(`‚úó Failed to read template: ${error.message}`);
        return;
    }

    // Replace placeholders
    const currentDate = new Date().toISOString().split('T')[0];
    const superpowersPath = paths.superpowersRepo;
    
    // Get available skills list
    let skillsList = '';
    try {
        const output = execSync(`"${join(__dirname, 'superpowers-agent')}" find-skills`, {
            encoding: 'utf8',
            stdio: 'pipe'
        });
        skillsList = '\n```\n' + output + '```\n';
    } catch {
        skillsList = '\nRun `~/.agents/superpowers/.agents/superpowers-agent find-skills` to see available skills.\n';
    }

    let content = template;
    content = content.replace(/\{\{DATE\}\}/g, currentDate);
    content = content.replace(/\{\{SUPERPOWERS_PATH\}\}/g, superpowersPath);
    content = content.replace(/\{\{AVAILABLE_SKILLS_LIST\}\}/g, skillsList);

    // Write AGENTS.md
    try {
        writeFileSync(agentsMdPath, content, 'utf8');
        console.log('‚úì Created AGENTS.md from template');
    } catch (error) {
        console.log(`‚úó Failed to write AGENTS.md: ${error.message}`);
        return;
    }

    console.log('');
    console.log('# Setup complete!');
    console.log('');
    console.log('Your project now has:');
    console.log('  - .agents/ directory structure');
    console.log('  - AGENTS.md with universal skills instructions');
    console.log('  - .agents/skills/ ready for project-specific skills');
    console.log('');
    if (existsSync(`${agentsMdPath}.backup-${new Date().toISOString().split('T')[0]}`)) {
        console.log('üí° Review the backup and new AGENTS.md to merge any custom content');
        console.log('');
    }
};

const runUpdate = (options = {}) => {
    const skipReinstall = options.skipReinstall || false;
    
    console.log('# Checking for Superpowers updates...');
    console.log('');
    
    // 1. Check current state
    const updateInfo = checkForUpdates();
    
    if (updateInfo.error) {
        console.log('‚ö†Ô∏è  Could not check for updates (network issue)');
        return;
    }
    
    if (!updateInfo.hasUpdates) {
        console.log('‚úì Already up to date');
        return;
    }
    
    // 2. Safety check - is repo clean?
    if (updateInfo.hasLocalChanges) {
        console.log('‚ö†Ô∏è  Cannot auto-update: local changes detected');
        console.log('   Commit or stash your changes first, then run update again');
        console.log(`   Or manually update: cd ${paths.superpowersRepo} && git pull`);
        return;
    }
    
    // 3. Check if on main branch
    if (!isOnMainBranch()) {
        console.log('‚ö†Ô∏è  Not on main branch, skipping auto-update');
        console.log(`   Switch to main branch first: cd ${paths.superpowersRepo} && git checkout main`);
        return;
    }
    
    // 4. Perform git pull
    console.log(`üì¶ Updating from ${updateInfo.currentCommit.substring(0,7)} to ${updateInfo.latestCommit.substring(0,7)}`);
    console.log(`   (${updateInfo.commitsBehind} new commit${updateInfo.commitsBehind > 1 ? 's' : ''})`);
    console.log('');
    
    try {
        execSync('git pull origin main', { 
            cwd: paths.superpowersRepo, 
            stdio: 'pipe',
            timeout: 10000
        });
        console.log('‚úì Updated superpowers repository');
    } catch (error) {
        console.log('‚úó Git pull failed:', error.message);
        console.log('   Please resolve manually and try again');
        return;
    }
    
    console.log('');
    
    // 5. Update config
    writeConfig({ 
        last_updated_commit: updateInfo.latestCommit,
        last_update_check: new Date().toISOString()
    });
    
    // 6. Determine what needs reinstalling
    if (skipReinstall) {
        console.log('‚ÑπÔ∏è  Skipping integration reinstall (--no-reinstall flag)');
        console.log('');
        console.log('‚úì Update complete!');
        return;
    }
    
    const integrationsToReinstall = determineReinstalls(updateInfo.changedFiles);
    
    if (integrationsToReinstall.length === 0) {
        console.log('‚ÑπÔ∏è  No integration files changed, skipping reinstalls');
        console.log('');
        console.log('‚úì Update complete!');
        return;
    }
    
    // 7. Reinstall affected integrations
    console.log('üîÑ Reinstalling updated integrations:');
    console.log('');
    
    const results = [];
    for (const integration of integrationsToReinstall) {
        const result = reinstallIntegration(integration);
        results.push(result);
        if (result.success) {
            console.log(`  ‚úì ${integration}`);
        } else {
            console.log(`  ‚úó ${integration} (${result.error})`);
        }
    }
    
    console.log('');
    
    // 8. Show summary
    const failures = results.filter(r => !r.success);
    if (failures.length > 0) {
        console.log('‚ö†Ô∏è  Update completed with errors:');
        for (const failure of failures) {
            console.log(`  - ${failure.integration} failed to install`);
            const commandName = `install-${failure.integration}`;
            console.log(`    Run manually: ~/.agents/superpowers/.agents/superpowers-agent ${commandName}`);
        }
    } else {
        console.log('‚úì Update complete!');
    }
};

const runBootstrap = () => {
    console.log('# Superpowers Bootstrap for Agents');
    console.log('# ==================================');
    console.log('');

    // Check for --no-update flag
    const noUpdate = process.argv.includes('--no-update');

    // Auto-update check
    if (!noUpdate) {
        const config = readConfig();
        const updateInfo = checkForUpdates();
        
        if (updateInfo.error) {
            console.log('## Update Check');
            console.log('');
            console.log('‚ö†Ô∏è  Could not check for updates (network issue)');
            console.log('');
            console.log('---');
            console.log('');
        } else if (updateInfo.hasUpdates) {
            if (config.auto_update && !updateInfo.hasLocalChanges && isOnMainBranch()) {
                console.log('## Auto-Update');
                console.log('');
                runUpdate();
                console.log('');
                console.log('---');
                console.log('');
            } else {
                console.log('## Update Available');
                console.log('');
                if (updateInfo.hasLocalChanges) {
                    console.log('‚ö†Ô∏è  Your superpowers installation is behind the latest version.');
                    console.log('    Cannot auto-update: local changes detected');
                    console.log(`    To update, commit/stash changes then run: \`~/.agents/superpowers/.agents/superpowers-agent update\``);
                } else if (!isOnMainBranch()) {
                    console.log('‚ö†Ô∏è  Your superpowers installation is behind the latest version.');
                    console.log('    Cannot auto-update: not on main branch');
                    console.log(`    To update, switch to main then run: \`~/.agents/superpowers/.agents/superpowers-agent update\``);
                } else {
                    console.log('‚ö†Ô∏è  Your superpowers installation is behind the latest version.');
                    console.log(`    To update, run: \`~/.agents/superpowers/.agents/superpowers-agent update\``);
                    console.log('    Or enable auto-update: `~/.agents/superpowers/.agents/superpowers-agent config-set auto_update true`');
                }
                console.log('');
                console.log('---');
                console.log('');
            }
        }
    }

    // Install GitHub Copilot integration (always, it's IDE-based)
    console.log('## GitHub Copilot Integration');
    console.log('');
    installCopilotPrompts();
    console.log('');
    installCopilotInstructions();
    console.log('');
    console.log('---');
    console.log('');

    // Install Cursor integration (always, it's IDE-based)
    console.log('## Cursor Integration');
    console.log('');
    installCursorCommands();
    console.log('');
    installCursorHooks();
    console.log('');
    console.log('---');
    console.log('');

    // Install OpenAI Codex integration
    console.log('## OpenAI Codex Integration');
    console.log('');
    const codexDetected = toolDetection.codex.check();
    if (codexDetected) {
        installCodexPrompts();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.codex.name} CLI not detected)`);
        console.log('üí° To enable Codex integration:');
        console.log(`   1. Install Codex: ${toolDetection.codex.installUrl}`);
        console.log(`   2. Run: ~/.agents/superpowers/.agents/superpowers-agent ${toolDetection.codex.bootstrapCommand}`);
    }
    console.log('');
    console.log('---');
    console.log('');

    // Install Gemini integration
    console.log('## Gemini Integration');
    console.log('');
    const geminiDetected = toolDetection.gemini.check();
    if (geminiDetected) {
        installGeminiCommands();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.gemini.name} CLI not detected)`);
        console.log('üí° To enable Gemini integration:');
        console.log(`   1. Install Gemini: ${toolDetection.gemini.installUrl}`);
        console.log(`   2. Run: ~/.agents/superpowers/.agents/superpowers-agent ${toolDetection.gemini.bootstrapCommand}`);
    }
    console.log('');
    console.log('---');
    console.log('');

    // Install Claude Code integration
    console.log('## Claude Code Integration');
    console.log('');
    const claudeDetected = toolDetection.claude.check();
    if (claudeDetected) {
        installClaudeCommands();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.claude.name} CLI not detected)`);
        console.log('üí° To enable Claude Code integration:');
        console.log(`   1. Install Claude Code: ${toolDetection.claude.installUrl}`);
        console.log(`   2. Run: ~/.agents/superpowers/.agents/superpowers-agent ${toolDetection.claude.bootstrapCommand}`);
    }
    console.log('');
    console.log('---');
    console.log('');

    // Install opencode integration
    console.log('## opencode Integration');
    console.log('');
    const opencodeDetected = toolDetection.opencode.check();
    if (opencodeDetected) {
        installOpencodeCommands();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.opencode.name} CLI not detected)`);
        console.log('üí° To enable OpenCode integration:');
        console.log(`   1. Install OpenCode: ${toolDetection.opencode.installUrl}`);
        console.log(`   2. Run: ~/.agents/superpowers/.agents/superpowers-agent ${toolDetection.opencode.bootstrapCommand}`);
    }
    console.log('');
    console.log('---');
    console.log('');

    // Show bootstrap instructions
    if (existsSync(paths.bootstrap)) {
        console.log('## Bootstrap Instructions:');
        console.log('');
        try {
            const content = readFileSync(paths.bootstrap, 'utf8');
            console.log(content);
        } catch (error) {
            console.log(`Error reading bootstrap file: ${error.message}`);
        }
        console.log('');
        console.log('---');
        console.log('');
    }

    // Show available skills
    console.log('## Available Skills:');
    console.log('');
    runFindSkills();
    console.log('');
    console.log('---');
    console.log('');

    // Auto-load using-superpowers skill if it exists
    const usingSuperpowersPath = join(paths.homeSuperpowersSkills, 'using-superpowers', 'SKILL.md');
    if (existsSync(usingSuperpowersPath)) {
        console.log('## Auto-loading superpowers:using-superpowers skill:');
        console.log('');
        runUseSkill('superpowers:using-superpowers');
        console.log('');
        console.log('---');
        console.log('');
    }

    console.log('# Bootstrap Complete!');
    console.log('# You now have access to all skills.');
    console.log('# Use ".agents/superpowers-agent use-skill <skill>" to load and apply skills.');
    console.log('# Remember: If a skill applies to your task, you MUST use it!');
};

const parseSkillName = (skillName) => {
    if (skillName.startsWith('superpowers:')) {
        return { type: 'superpowers', path: skillName.substring(12).replace(/^skills\//, '') };
    }
    if (skillName.startsWith('claude:')) {
        return { type: 'claude', path: skillName.substring(7).replace(/^skills\//, '') };
    }
    return { type: null, path: skillName.replace(/^skills\//, '') };
};

const findSkillFile = (searchPath) => {
    const skillMdPath = join(searchPath, 'SKILL.md');
    if (existsSync(skillMdPath)) return skillMdPath;
    if (searchPath.endsWith('SKILL.md') && existsSync(searchPath)) return searchPath;
    return null;
};

const locateSkill = (skillName) => {
    const { type, path: actualSkillPath } = parseSkillName(skillName);
    
    // Map type to directory path
    const typeToDirMap = {
        'superpowers': paths.homeSuperpowersSkills,
        'claude': paths.projectClaudeSkills,
        'project': paths.projectAgentsSkills,
        'personal': paths.homePersonalSkills
    };
    
    // Search order configuration
    const searchOrder = type 
        ? [{ type, dir: typeToDirMap[type] }]
        : [
            { type: 'project', dir: paths.projectAgentsSkills },
            { type: 'claude', dir: paths.projectClaudeSkills },
            { type: 'personal', dir: paths.homePersonalSkills },
            { type: 'superpowers', dir: paths.homeSuperpowersSkills }
          ];

    for (const { type: sourceType, dir } of searchOrder) {
        const skillPath = join(dir, actualSkillPath);
        const skillFile = findSkillFile(skillPath);
        if (skillFile) {
            return { skillFile, sourceType, actualSkillPath };
        }
    }

    return null;
};

const extractSkillContent = (skillFile) => {
    try {
        const fullContent = readFileSync(skillFile, 'utf8');
        const frontmatter = extractFrontmatter(skillFile);
        
        const lines = fullContent.split('\n');
        let inFrontmatter = false;
        let frontmatterEnded = false;
        const contentLines = [];

        for (const line of lines) {
            if (line.trim() === '---') {
                if (inFrontmatter) {
                    frontmatterEnded = true;
                    continue;
                }
                inFrontmatter = true;
                continue;
            }

            if (frontmatterEnded || !inFrontmatter) {
                contentLines.push(line);
            }
        }

        return {
            content: contentLines.join('\n').trim(),
            frontmatter
        };
    } catch (error) {
        throw new Error(`Error reading skill file: ${error.message}`);
    }
};

const runUseSkill = (skillName) => {
    if (!skillName) {
        console.log('Usage: .agents/superpowers-agent use-skill <skill-name>');
        console.log('Examples:');
        console.log('  .agents/superpowers-agent use-skill superpowers:brainstorming  # Load superpowers skill');
        console.log('  .agents/superpowers-agent use-skill claude:persistent-planning # Load claude skill');
        console.log('  .agents/superpowers-agent use-skill brainstorming              # Load project/personal skill');
        console.log('  .agents/superpowers-agent use-skill my-custom-skill            # Load project skill');
        return;
    }

    const location = locateSkill(skillName);
    
    if (!location) {
        console.log(`Error: Skill not found: ${skillName}`);
        console.log('');
        console.log('Available skills:');
        runFindSkills();
        return;
    }

    const { skillFile, sourceType, actualSkillPath } = location;
    
    try {
        const { content, frontmatter } = extractSkillContent(skillFile);
        const displayName = skillTypes[sourceType].prefix + actualSkillPath;
        const skillDirectory = dirname(skillFile);

        // Display skill header
        console.log(`# ${frontmatter.name || displayName}`);
        if (frontmatter.description) console.log(`# ${frontmatter.description}`);
        if (frontmatter.whenToUse) console.log(`# When to use: ${frontmatter.whenToUse}`);
        console.log(`# Supporting tools and docs are in ${skillDirectory}`);
        console.log('# ============================================');
        console.log('');
        console.log(content);
    } catch (error) {
        console.log(error.message);
    }
};

const runConfigGet = () => {
    const config = readConfig();
    console.log('Current configuration:');
    console.log(JSON.stringify(config, null, 2));
};

const runConfigSet = () => {
    const key = process.argv[3];
    const value = process.argv[4];
    
    if (!key || value === undefined) {
        console.log('Usage: .agents/superpowers-agent config-set <key> <value>');
        console.log('');
        console.log('Available keys:');
        console.log('  auto_update (true/false) - Enable/disable automatic updates during bootstrap');
        console.log('');
        console.log('Examples:');
        console.log('  .agents/superpowers-agent config-set auto_update false');
        console.log('  .agents/superpowers-agent config-set auto_update true');
        return;
    }
    
    // Parse boolean strings
    let parsedValue = value;
    if (value === 'true') parsedValue = true;
    else if (value === 'false') parsedValue = false;
    
    const updates = {};
    updates[key] = parsedValue;
    writeConfig(updates);
    
    console.log(`‚úì Set ${key} = ${parsedValue}`);
};

// Command dispatcher
const commands = {
    bootstrap: runBootstrap,
    update: () => {
        const skipReinstall = process.argv.includes('--no-reinstall');
        runUpdate({ skipReinstall });
    },
    'config-get': runConfigGet,
    'config-set': runConfigSet,
    'setup-skills': runSetupSkills,
    'use-skill': () => runUseSkill(process.argv[3]),
    'find-skills': runFindSkills,
    'install-copilot-prompts': installCopilotPrompts,
    'install-copilot-instructions': installCopilotInstructions,
    'install-cursor-commands': installCursorCommands,
    'install-cursor-hooks': installCursorHooks,
    'install-codex-prompts': installCodexPrompts,
    'install-gemini-commands': installGeminiCommands,
    'install-claude-commands': installClaudeCommands,
    'install-opencode-commands': installOpencodeCommands,
    default: () => {
        console.log('Superpowers for Agents');
        console.log('Usage:');
        console.log('  .agents/superpowers-agent bootstrap [--no-update]        # Run complete bootstrap with all skills');
        console.log('  .agents/superpowers-agent update [--no-reinstall]        # Update to latest version from GitHub');
        console.log('  .agents/superpowers-agent config-get                     # Show current configuration');
        console.log('  .agents/superpowers-agent config-set <key> <value>       # Update configuration');
        console.log('  .agents/superpowers-agent setup-skills                   # Initialize project with skills documentation');
        console.log('  .agents/superpowers-agent use-skill <skill-name>         # Load a specific skill');
        console.log('  .agents/superpowers-agent find-skills                    # List all available skills');
        console.log('  .agents/superpowers-agent install-copilot-prompts        # Install GitHub Copilot prompts only');
        console.log('  .agents/superpowers-agent install-copilot-instructions   # Install universal instructions only');
        console.log('  .agents/superpowers-agent install-cursor-commands        # Install Cursor commands only');
        console.log('  .agents/superpowers-agent install-cursor-hooks           # Install Cursor hooks only');
        console.log('  .agents/superpowers-agent install-codex-prompts          # Install OpenAI Codex prompts only');
        console.log('  .agents/superpowers-agent install-gemini-commands        # Install Gemini commands only');
        console.log('  .agents/superpowers-agent install-claude-commands        # Install Claude Code commands only');
        console.log('  .agents/superpowers-agent install-opencode-commands      # Install opencode commands only');
        console.log('');
        console.log('Examples:');
        console.log('  .agents/superpowers-agent bootstrap                      # Auto-update then bootstrap');
        console.log('  .agents/superpowers-agent bootstrap --no-update          # Skip update, just bootstrap');
        console.log('  .agents/superpowers-agent update                         # Update and reinstall changed integrations');
        console.log('  .agents/superpowers-agent config-set auto_update false   # Disable auto-update');
        console.log('  .agents/superpowers-agent use-skill superpowers:brainstorming');
        console.log('  .agents/superpowers-agent use-skill claude:persistent-planning');
        console.log('  .agents/superpowers-agent use-skill my-custom-skill');
    }
};

// Main execution
const command = process.argv[2];
const handler = commands[command] || commands.default;
handler();
