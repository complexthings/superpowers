#!/usr/bin/env node

import { readFileSync, writeFileSync, readdirSync, existsSync } from 'fs';
import { join, parse, dirname, relative } from 'path';
import { homedir, platform } from 'os';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Get VS Code User profile directory based on platform
const getVSCodeUserDir = () => {
    const home = homedir();
    const plat = platform();
    
    switch (plat) {
        case 'darwin': // macOS
            return join(home, 'Library', 'Application Support', 'Code', 'User');
        case 'win32': // Windows
            return join(home, 'AppData', 'Roaming', 'Code', 'User');
        case 'linux': // Linux
            return join(home, '.config', 'Code', 'User');
        default:
            // Fallback to Linux path for unknown platforms
            return join(home, '.config', 'Code', 'User');
    }
};

// Detect project root (where .agents directory exists)
const findProjectRoot = () => {
    let currentDir = process.cwd();
    const root = parse(currentDir).root;
    
    while (currentDir !== root) {
        if (existsSync(join(currentDir, '.agents'))) {
            return currentDir;
        }
        currentDir = dirname(currentDir);
    }
    
    return process.cwd();
};

// Paths configuration
const paths = {
    home: homedir(),
    vscodeUserDir: getVSCodeUserDir(),
    projectRoot: findProjectRoot(),
    get projectClaudeSkills() { return join(this.projectRoot, '.claude', 'skills'); },
    get projectAgentsSkills() { return join(this.projectRoot, '.agents', 'skills'); },
    get homePersonalSkills() { return join(this.home, '.agents', 'skills'); },
    get bootstrap() { return join(this.projectRoot, '.agents', 'superpowers-bootstrap.md'); },
    get superpowersRepo() { 
        // If running from the superpowers repo itself, use current location
        // Otherwise use installed location
        const currentRepoCheck = join(__dirname, '..', 'skills');
        if (existsSync(currentRepoCheck) && existsSync(join(__dirname, '..', '.github', 'prompts'))) {
            return join(__dirname, '..');
        }
        return join(this.home, '.agents', 'superpowers');
    },
    get homeSuperpowersSkills() { return join(this.superpowersRepo, 'skills'); }
};

// Utility functions
const getDefaultConfig = () => ({
    auto_update: true,
    last_update_check: null,
    last_updated_commit: null
});

const readConfig = () => {
    const configPath = join(paths.superpowersRepo, '.config.json');
    try {
        if (!existsSync(configPath)) {
            return getDefaultConfig();
        }
        const content = readFileSync(configPath, 'utf8');
        return { ...getDefaultConfig(), ...JSON.parse(content) };
    } catch {
        return getDefaultConfig();
    }
};

const writeConfig = (updates) => {
    const configPath = join(paths.superpowersRepo, '.config.json');
    const current = readConfig();
    const updated = { ...current, ...updates };
    try {
        writeFileSync(configPath, JSON.stringify(updated, null, 2));
    } catch (error) {
        console.log(`Warning: couldn't save config: ${error.message}`);
    }
};

const isRepoClean = () => {
    try {
        const output = execSync('git status --porcelain', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe',
            timeout: 3000
        });
        return output.trim().length === 0;
    } catch {
        return false;
    }
};

const isOnMainBranch = () => {
    try {
        const branch = execSync('git rev-parse --abbrev-ref HEAD', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe',
            timeout: 3000
        });
        return branch.trim() === 'main';
    } catch {
        return false;
    }
};

const checkForUpdates = () => {
    try {
        // Fetch latest from origin
        execSync('git fetch origin', {
            cwd: paths.superpowersRepo,
            timeout: 5000,
            stdio: 'pipe'
        });

        // Check if repo is clean
        const hasLocalChanges = !isRepoClean();

        // Get current and latest commits
        const currentCommit = execSync('git rev-parse HEAD', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();

        const latestCommit = execSync('git rev-parse origin/main', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();

        const hasUpdates = currentCommit !== latestCommit;

        if (!hasUpdates) {
            return {
                hasUpdates: false,
                hasLocalChanges,
                currentCommit,
                latestCommit,
                commitsBehind: 0,
                changedFiles: []
            };
        }

        // Count commits behind
        const commitsBehind = parseInt(execSync('git rev-list --count HEAD..origin/main', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim(), 10);

        // Get changed files
        const changedFilesOutput = execSync('git diff --name-only HEAD origin/main', {
            cwd: paths.superpowersRepo,
            encoding: 'utf8',
            stdio: 'pipe'
        });

        const changedFiles = changedFilesOutput.trim().split('\n').filter(f => f.length > 0);

        return {
            hasUpdates: true,
            hasLocalChanges,
            currentCommit,
            latestCommit,
            commitsBehind,
            changedFiles
        };
    } catch {
        return {
            hasUpdates: false,
            hasLocalChanges: false,
            currentCommit: '',
            latestCommit: '',
            commitsBehind: 0,
            changedFiles: [],
            error: true
        };
    }
};

const determineReinstalls = (changedFiles) => {
    const integrationMap = {
        '.github/prompts/': 'copilot-prompts',
        '.github/copilot-instructions.md': 'copilot-instructions',
        '.cursor/commands/': 'cursor-commands',
        'hooks/cursor/': 'cursor-hooks',
        '.codex/prompts/': 'codex-prompts',
        '.gemini/commands/': 'gemini-commands',
        'commands/': 'claude-commands',
        '.opencode/command/': 'opencode-commands'
    };
    
    const toReinstall = new Set();
    
    for (const file of changedFiles) {
        for (const [pathPrefix, integration] of Object.entries(integrationMap)) {
            if (file.startsWith(pathPrefix)) {
                toReinstall.add(integration);
            }
        }
    }
    
    return Array.from(toReinstall);
};

const reinstallIntegration = (integration) => {
    const installFunctions = {
        'copilot-prompts': installCopilotPrompts,
        'copilot-instructions': installCopilotInstructions,
        'cursor-commands': installCursorCommands,
        'cursor-hooks': installCursorHooks,
        'codex-prompts': installCodexPrompts,
        'gemini-commands': installGeminiCommands,
        'claude-commands': installClaudeCommands,
        'opencode-commands': installOpencodeCommands
    };
    
    const installFn = installFunctions[integration];
    if (installFn) {
        try {
            installFn();
            return { success: true, integration };
        } catch (error) {
            return { success: false, integration, error: error.message };
        }
    }
    return { success: false, integration, error: 'Unknown integration' };
};

const detectTool = (command) => {
    try {
        execSync(`which ${command}`, { 
            stdio: 'pipe',
            timeout: 2000 
        });
        return true;
    } catch {
        return false;
    }
};

const toolDetection = {
    opencode: { 
        check: () => detectTool('opencode'), 
        cli: true,
        name: 'OpenCode',
        installUrl: 'https://opencode.ai/docs/installation',
        bootstrapCommand: 'install-opencode-commands'
    },
    claude: { 
        check: () => detectTool('claude'), 
        cli: true,
        name: 'Claude Code',
        installUrl: 'https://code.claude.com/docs/en/installation',
        bootstrapCommand: 'install-claude-commands'
    },
    gemini: { 
        check: () => detectTool('gemini'), 
        cli: true,
        name: 'Gemini',
        installUrl: 'https://cloud.google.com/gemini/docs/cli/install',
        bootstrapCommand: 'install-gemini-commands'
    },
    codex: { 
        check: () => detectTool('codex'), 
        cli: true,
        name: 'Codex',
        installUrl: 'https://developers.openai.com/codex/docs/installation',
        bootstrapCommand: 'install-codex-prompts'
    },
    cursor: { 
        check: () => true, 
        cli: false,
        name: 'Cursor',
        bootstrapCommand: 'install-cursor-commands'
    },
    copilot: { 
        check: () => true, 
        cli: false,
        name: 'GitHub Copilot',
        bootstrapCommand: 'install-copilot-prompts'
    }
};

const extractFrontmatter = (filePath) => {
    try {
        const content = readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        const frontmatter = { name: '', description: '', whenToUse: '' };
        let inFrontmatter = false;

        for (const line of lines) {
            if (line.trim() === '---') {
                if (inFrontmatter) break;
                inFrontmatter = true;
                continue;
            }

            if (inFrontmatter) {
                const match = line.match(/^(\w+):\s*(.*)$/);
                if (match) {
                    const [, key, value] = match;
                    const fieldMap = {
                        'name': 'name',
                        'description': 'description',
                        'when_to_use': 'whenToUse'
                    };
                    if (fieldMap[key]) {
                        frontmatter[fieldMap[key]] = value.trim();
                    }
                }
            }
        }

        return frontmatter;
    } catch {
        return { name: '', description: '', whenToUse: '' };
    }
};

const skillTypes = {
    claude: { dir: 'projectClaudeSkills', prefix: 'claude:' },
    project: { dir: 'projectAgentsSkills', prefix: '' },
    personal: { dir: 'homePersonalSkills', prefix: '' },
    superpowers: { dir: 'homeSuperpowersSkills', prefix: 'superpowers:' }
};

const printSkill = (skillPath, sourceType) => {
    const skillFile = join(skillPath, 'SKILL.md');
    const { dir, prefix } = skillTypes[sourceType];
    const relPath = relative(paths[dir], skillPath).replace(/\\/g, '/');
    
    console.log(`${prefix}${relPath}`);
    
    const { description, whenToUse } = extractFrontmatter(skillFile);
    if (description) console.log(`  ${description}`);
    if (whenToUse) console.log(`  When to use: ${whenToUse}`);
    console.log('');
};

const findSkillsInDir = (dir, sourceType, maxDepth = 1) => {
    const skills = [];
    if (!existsSync(dir)) return skills;

    const searchDir = (currentDir, currentDepth) => {
        if (currentDepth > maxDepth) return;

        try {
            const entries = readdirSync(currentDir, { withFileTypes: true });

            for (const entry of entries) {
                if (!entry.isDirectory()) continue;
                
                const skillDir = join(currentDir, entry.name);
                const skillFile = join(skillDir, 'SKILL.md');

                if (existsSync(skillFile)) {
                    skills.push(skillDir);
                }

                if (currentDepth < maxDepth) {
                    searchDir(skillDir, currentDepth + 1);
                }
            }
        } catch {
            // Ignore permission errors
        }
    };

    searchDir(dir, 0);
    return skills;
};

// Commands
const runFindSkills = () => {
    console.log('Available skills:\n==================\n');

    const foundSkills = new Set();
    
    // Skill discovery order (priority: project > claude > personal > superpowers)
    const discoveryOrder = [
        { type: 'project', dir: paths.projectAgentsSkills, maxDepth: 2 },
        { type: 'claude', dir: paths.projectClaudeSkills, maxDepth: 2 },
        { type: 'personal', dir: paths.homePersonalSkills, maxDepth: 2 },
        { type: 'superpowers', dir: paths.homeSuperpowersSkills, maxDepth: 1 }
    ];

    for (const { type, dir, maxDepth } of discoveryOrder) {
        const skills = findSkillsInDir(dir, type, maxDepth);
        for (const skillPath of skills) {
            const relPath = relative(dir, skillPath);
            if (!foundSkills.has(relPath)) {
                foundSkills.add(relPath);
                printSkill(skillPath, type);
            }
        }
    }

    console.log(`Usage:
  superpowers-agent use-skill <skill-name> # Load a specific skill

Skill naming:
  Project skills: skill-name (from .agents/skills/ - highest priority)
  Claude skills: claude:skill-name (from .claude/skills/)
  Personal skills: skill-name (from ~/.agents/skills/)
  Superpowers skills: superpowers:skill-name (from ~/.agents/superpowers/skills/)

Priority: .agents/skills > .claude/skills > ~/.agents/skills > ~/.agents/superpowers/skills
Note: All skills are disclosed at session start via bootstrap.`);
};

const findSectionEnd = (content, sectionStart) => {
    // Find the heading level of the section
    const headingMatch = content.substring(sectionStart).match(/^(#+)/m);
    if (!headingMatch) return content.length;
    
    const headingLevel = headingMatch[1];
    
    // Find next same-level or higher heading, or ---
    const afterSection = content.substring(sectionStart + headingMatch[0].length);
    const nextHeadingRegex = new RegExp(`^${headingLevel}+ `, 'm');
    const hrRegex = /^---+$/m;
    
    const nextHeading = afterSection.match(nextHeadingRegex);
    const nextHr = afterSection.match(hrRegex);
    
    if (nextHeading && nextHr) {
        const endIndex = Math.min(nextHeading.index, nextHr.index);
        return sectionStart + headingMatch[0].length + endIndex;
    } else if (nextHeading) {
        return sectionStart + headingMatch[0].length + nextHeading.index;
    } else if (nextHr) {
        return sectionStart + headingMatch[0].length + nextHr.index;
    }
    
    return content.length;
};

const findSkillsSection = (content) => {
    // 1. Try markers first
    const markerRegex = /<!-- SUPERPOWERS_SKILLS_START -->([\s\S]*?)<!-- SUPERPOWERS_SKILLS_END -->/;
    const markerMatch = content.match(markerRegex);
    if (markerMatch) {
        return { 
            type: 'markers', 
            start: markerMatch.index, 
            end: markerMatch.index + markerMatch[0].length 
        };
    }
    
    // 2. Try pattern detection
    const patterns = [
        /^##\s*üéØ\s*CRITICAL:\s*SKILLS.*$/im,
        /^###\s*HOW SKILLS WORK.*$/im,
        /^##\s*CRITICAL.*SKILLS.*$/im
    ];
    
    for (const pattern of patterns) {
        const match = content.match(pattern);
        if (match) {
            const sectionEnd = findSectionEnd(content, match.index);
            return { type: 'pattern', start: match.index, end: sectionEnd };
        }
    }
    
    // 3. Fall back to after first heading
    const firstHeadingMatch = content.match(/^#+ .+$/m);
    if (firstHeadingMatch) {
        const insertPoint = firstHeadingMatch.index + firstHeadingMatch[0].length;
        return { type: 'after-intro', start: insertPoint, end: insertPoint };
    }
    
    return null;
};

const extractSkillsSection = (templateContent) => {
    // If template already has markers, extract content between them
    const markerRegex = /<!-- SUPERPOWERS_SKILLS_START -->([\s\S]*?)<!-- SUPERPOWERS_SKILLS_END -->/;
    const match = templateContent.match(markerRegex);
    if (match) {
        return match[1].trim();
    }
    
    // Otherwise return the full template (it will get markers added during update)
    return templateContent.trim();
};

const updateAgentFile = (filePath, templateContent) => {
    // 1. Check if file exists
    if (!existsSync(filePath)) {
        return { skipped: true, reason: 'File does not exist' };
    }
    
    // 2. Backup existing file
    const timestamp = new Date().toISOString().split('T')[0];
    const backupPath = `${filePath}.backup-${timestamp}`;
    try {
        execSync(`cp "${filePath}" "${backupPath}"`, { stdio: 'pipe' });
    } catch (error) {
        console.log(`‚ö†Ô∏è  Could not create backup: ${error.message}\n  Skipping update to preserve existing content`);
        return { error: true };
    }
    
    // 3. Read current content
    let currentContent;
    try {
        currentContent = readFileSync(filePath, 'utf8');
    } catch (error) {
        console.log(`‚úó Failed to read ${parse(filePath).base}: ${error.message}`);
        return { error: true };
    }
    
    // 4. Find skills section
    const section = findSkillsSection(currentContent);
    
    if (!section) {
        console.log(`‚ö†Ô∏è  Could not detect skills section in ${parse(filePath).base}\n  Skipping update to preserve file structure`);
        return { error: true };
    }
    
    // 5. Prepare template with markers
    const markedTemplate = `<!-- SUPERPOWERS_SKILLS_START -->\n${templateContent}\n<!-- SUPERPOWERS_SKILLS_END -->`;
    
    // 6. Build new content based on detection type
    let newContent;
    if (section.type === 'markers' || section.type === 'pattern') {
        // Replace detected section
        newContent = currentContent.substring(0, section.start) + 
                     markedTemplate + 
                     currentContent.substring(section.end);
    } else if (section.type === 'after-intro') {
        // Insert after first heading
        newContent = currentContent.substring(0, section.start) +
                     '\n\n' + markedTemplate + '\n\n' +
                     currentContent.substring(section.start);
    }
    
    // 7. Write updated content
    try {
        writeFileSync(filePath, newContent, 'utf8');
    } catch (error) {
        console.log(`‚úó Failed to write ${parse(filePath).base}: ${error.message}`);
        return { error: true };
    }
    
    return { updated: true, type: section.type, backup: parse(backupPath).base };
};

const installCopilotPrompts = () => {
    const promptsSourceDir = join(paths.superpowersRepo, '.github', 'prompts');
    const promptsDestDir = join(paths.vscodeUserDir, 'prompts');
    
    if (!existsSync(promptsSourceDir)) {
        console.log('‚ö†Ô∏è  No Copilot prompts to install (source directory not found).');
        return;
    }
    
    // Create destination directory
    try {
        if (!existsSync(promptsDestDir)) {
            execSync(`mkdir -p "${promptsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating prompts directory: ${error.message}`);
        return;
    }
    
    // Copy all .prompt.md files
    let promptFiles;
    try {
        promptFiles = readdirSync(promptsSourceDir)
            .filter(f => f.endsWith('.prompt.md'));
    } catch (error) {
        console.log(`Error reading prompts directory: ${error.message}`);
        return;
    }
    
    if (promptFiles.length === 0) {
        console.log('‚ö†Ô∏è  No prompt files found to install.');
        return;
    }
    
    console.log('Installing GitHub Copilot prompts...');
    let installed = 0;
    for (const file of promptFiles) {
        try {
            const source = join(promptsSourceDir, file);
            const dest = join(promptsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }
    
    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} prompt(s) to ${promptsDestDir}\n  Use slash commands in GitHub Copilot:\n    /brainstorm-with-superpowers - Refine ideas into designs\n    /write-a-skill - Create new skills with TDD\n    /skills - Discover available skills\n    /use-skill - Load and apply a specific skill`);
    }
};

const installCopilotInstructions = () => {
    const instructionsSource = join(paths.superpowersRepo, '.github', 'copilot-instructions.md');
    const instructionsDest = join(paths.home, '.github', 'copilot-instructions.md');
    
    if (!existsSync(instructionsSource)) {
        console.log('‚ö†Ô∏è  No Copilot instructions to install (source file not found).');
        return;
    }
    
    // Create destination directory
    const destDir = dirname(instructionsDest);
    try {
        if (!existsSync(destDir)) {
            execSync(`mkdir -p "${destDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating .github directory: ${error.message}`);
        return;
    }
    
    // Copy instructions
    try {
        execSync(`cp "${instructionsSource}" "${instructionsDest}"`, { stdio: 'pipe' });
        console.log(`‚úì Installed GitHub Copilot universal instructions\n  Location: ${instructionsDest}\n  GitHub Copilot will now use Superpowers skills universally in all workspaces`);
    } catch (error) {
        console.log(`‚úó Failed to install instructions: ${error.message}`);
    }
};

const installCursorCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, '.cursor', 'commands');
    const commandsDestDir = join(paths.home, '.cursor', 'commands');
    
    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No Cursor commands to install (source directory not found).');
        return;
    }
    
    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Cursor commands directory: ${error.message}`);
        return;
    }
    
    // Copy all .md files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading Cursor commands directory: ${error.message}`);
        return;
    }
    
    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }
    
    console.log('Installing Cursor commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }
    
    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}\n  Use slash commands in Cursor:\n    /brainstorm-with-superpowers - Refine ideas into designs\n    /write-a-skill - Create new skills with TDD\n    /skills - Discover available skills\n    /use-skill - Load and apply a specific skill`);
    }
};

const installCursorHooks = () => {
    const hooksSourceDir = join(paths.superpowersRepo, 'hooks', 'cursor');
    const hooksDestDir = join(paths.home, '.cursor', 'hooks');
    const hooksJsonSource = join(hooksSourceDir, 'hooks.json');
    const hooksJsonDest = join(paths.home, '.cursor', 'hooks.json');

    if (!existsSync(hooksSourceDir)) {
        console.log('‚ö†Ô∏è  No Cursor hooks to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(hooksDestDir)) {
            execSync(`mkdir -p "${hooksDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Cursor hooks directory: ${error.message}`);
        return;
    }

    // Copy hooks.json
    try {
        execSync(`cp "${hooksJsonSource}" "${hooksJsonDest}"`, { stdio: 'pipe' });
        console.log('  ‚úì Installed hooks.json');
    } catch (error) {
        console.log(`  ‚úó Failed to install hooks.json: ${error.message}`);
        return;
    }

    // Copy hook scripts
    let hookFiles;
    try {
        hookFiles = readdirSync(hooksSourceDir)
            .filter(f => f.endsWith('.sh'));
    } catch (error) {
        console.log(`Error reading hooks directory: ${error.message}`);
        return;
    }

    if (hookFiles.length === 0) {
        console.log('‚ö†Ô∏è  No hook scripts found to install.');
        return;
    }

    console.log('Installing Cursor hooks...');
    let installed = 0;
    for (const file of hookFiles) {
        try {
            const source = join(hooksSourceDir, file);
            const dest = join(hooksDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            execSync(`chmod +x "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} hook(s) to ${hooksDestDir}\n  Cursor will now auto-bootstrap skills at conversation start\n  Restart Cursor for hooks to take effect`);
    }
};

const installCodexPrompts = () => {
    const promptsSourceDir = join(paths.superpowersRepo, '.codex', 'prompts');
    const promptsDestDir = join(paths.home, '.codex', 'prompts');

    if (!existsSync(promptsSourceDir)) {
        console.log('‚ö†Ô∏è  No Codex prompts to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(promptsDestDir)) {
            execSync(`mkdir -p "${promptsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Codex prompts directory: ${error.message}`);
        return;
    }

    // Copy all .md files
    let promptFiles;
    try {
        promptFiles = readdirSync(promptsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading Codex prompts directory: ${error.message}`);
        return;
    }

    if (promptFiles.length === 0) {
        console.log('‚ö†Ô∏è  No prompt files found to install.');
        return;
    }

    console.log('Installing OpenAI Codex prompts...');
    let installed = 0;
    for (const file of promptFiles) {
        try {
            const source = join(promptsSourceDir, file);
            const dest = join(promptsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} prompt(s) to ${promptsDestDir}\n  Use slash commands in OpenAI Codex:\n    /prompts:brainstorm - Refine ideas into designs\n    /prompts:write-skill - Create new skills with TDD\n    /prompts:skills - Discover available skills\n    /prompts:use-skill - Load and apply a specific skill\n  Note: Restart Codex or open a new session to reload prompts`);
    }
};

const installGeminiCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, '.gemini', 'commands');
    const commandsDestDir = join(paths.home, '.gemini', 'commands');

    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No Gemini commands to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Gemini commands directory: ${error.message}`);
        return;
    }

    // Copy all .toml files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.toml'));
    } catch (error) {
        console.log(`Error reading Gemini commands directory: ${error.message}`);
        return;
    }

    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }

    console.log('Installing Gemini commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}\n  Use slash commands in Gemini:\n    /brainstorm-with-superpowers - Refine ideas into designs\n    /write-a-skill - Create new skills with TDD\n    /skills - Discover available skills\n    /use-skill - Load and apply a specific skill`);
    }
};

const installClaudeCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, 'commands');
    const commandsDestDir = join(paths.home, '.claude', 'commands');

    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No Claude commands to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating Claude commands directory: ${error.message}`);
        return;
    }

    // Copy all .md files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading Claude commands directory: ${error.message}`);
        return;
    }

    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }

    console.log('Installing Claude Code commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}\n  Use slash commands in Claude Code:\n    /brainstorm - Refine ideas into designs\n    /execute-plan - Execute plans in batches\n    /write-plan - Create implementation plans\n    /skills - Discover available skills\n    /use-skill - Load and apply a specific skill`);
    }
};

const installOpencodeCommands = () => {
    const commandsSourceDir = join(paths.superpowersRepo, '.opencode', 'command');
    const commandsDestDir = join(paths.home, '.config', 'opencode', 'command');

    if (!existsSync(commandsSourceDir)) {
        console.log('‚ö†Ô∏è  No opencode commands to install (source directory not found).');
        return;
    }

    // Create destination directory
    try {
        if (!existsSync(commandsDestDir)) {
            execSync(`mkdir -p "${commandsDestDir}"`, { stdio: 'pipe' });
        }
    } catch (error) {
        console.log(`Error creating opencode commands directory: ${error.message}`);
        return;
    }

    // Copy all .md files
    let commandFiles;
    try {
        commandFiles = readdirSync(commandsSourceDir)
            .filter(f => f.endsWith('.md'));
    } catch (error) {
        console.log(`Error reading opencode commands directory: ${error.message}`);
        return;
    }

    if (commandFiles.length === 0) {
        console.log('‚ö†Ô∏è  No command files found to install.');
        return;
    }

    console.log('Installing opencode commands...');
    let installed = 0;
    for (const file of commandFiles) {
        try {
            const source = join(commandsSourceDir, file);
            const dest = join(commandsDestDir, file);
            execSync(`cp "${source}" "${dest}"`, { stdio: 'pipe' });
            console.log(`  ‚úì Installed ${file}`);
            installed++;
        } catch (error) {
            console.log(`  ‚úó Failed to install ${file}: ${error.message}`);
        }
    }

    if (installed > 0) {
        console.log(`\n‚úì Installed ${installed} command(s) to ${commandsDestDir}\n  Use slash commands in opencode:\n    /brainstorm - Refine ideas into designs\n    /execute-plan - Execute plans in batches\n    /write-plan - Create implementation plans\n    /write-skill - Create new skills with TDD\n    /skills - Discover available skills\n    /use-skill - Load and apply a specific skill`);
    }
};

const runSetupSkills = () => {
    console.log('# Setting up Superpowers skills for this project\n');

    // ALWAYS use current directory as project root for setup-skills
    // Don't search upward - we're setting up THIS directory as a new project
    const projectRoot = process.cwd();
    const agentsDir = join(projectRoot, '.agents');
    const skillsDir = join(agentsDir, 'skills');
    const rootAgentsMdPath = join(projectRoot, 'AGENTS.md');
    const dotAgentsAgentsMdPath = join(agentsDir, 'AGENTS.md');
    // Prefer root AGENTS.md if it exists, otherwise use .agents/AGENTS.md
    const agentsMdPath = existsSync(rootAgentsMdPath) ? rootAgentsMdPath : dotAgentsAgentsMdPath;
    const templatePath = join(paths.superpowersRepo, '.agents', 'templates', 'AGENTS.md.template');

    // Check if template exists
    if (!existsSync(templatePath)) {
        console.log(`‚úó Error: AGENTS.md template not found\n  Expected at: ${templatePath}\n  Please update your Superpowers installation`);
        return;
    }

    // Create .agents directory
    if (!existsSync(agentsDir)) {
        try {
            execSync(`mkdir -p "${agentsDir}"`, { stdio: 'pipe' });
            console.log('‚úì Created .agents/ directory');
        } catch (error) {
            console.log(`‚úó Failed to create .agents/ directory: ${error.message}`);
            return;
        }
    } else {
        console.log('‚úì .agents/ directory exists');
    }

    // Create skills directory
    if (!existsSync(skillsDir)) {
        try {
            execSync(`mkdir -p "${skillsDir}"`, { stdio: 'pipe' });
            execSync(`touch "${join(skillsDir, '.gitkeep')}"`, { stdio: 'pipe' });
            console.log('‚úì Created .agents/skills/ directory');
        } catch (error) {
            console.log(`‚úó Failed to create skills directory: ${error.message}`);
            return;
        }
    } else {
        console.log('‚úì .agents/skills/ directory exists');
    }

    // Handle existing AGENTS.md
    const agentsMdExists = existsSync(agentsMdPath);
    
    if (agentsMdExists) {
        const timestamp = new Date().toISOString().split('T')[0];
        const backupPath = `${agentsMdPath}.backup-${timestamp}`;
        try {
            execSync(`cp "${agentsMdPath}" "${backupPath}"`, { stdio: 'pipe' });
            console.log(`‚úì Backed up existing AGENTS.md to ${parse(backupPath).base}`);
        } catch (error) {
            console.log(`‚úó Failed to backup AGENTS.md: ${error.message}`);
            return;
        }
    }

    // Read template
    let template;
    try {
        template = readFileSync(templatePath, 'utf8');
    } catch (error) {
        console.log(`‚úó Failed to read template: ${error.message}`);
        return;
    }

    // Replace placeholders
    const currentDate = new Date().toISOString().split('T')[0];
    const superpowersPath = paths.superpowersRepo;
    
    // Get available skills list
    let skillsList = '';
    try {
        const output = execSync(`"${join(__dirname, 'superpowers-agent')}" find-skills`, {
            encoding: 'utf8',
            stdio: 'pipe'
        });
        skillsList = '\n```\n' + output + '```\n';
    } catch {
        skillsList = '\nRun `superpowers-agent find-skills` to see available skills.\n';
    }

    let content = template;
    content = content.replace(/\{\{DATE\}\}/g, currentDate);
    content = content.replace(/\{\{SUPERPOWERS_PATH\}\}/g, superpowersPath);
    content = content.replace(/\{\{AVAILABLE_SKILLS_LIST\}\}/g, skillsList);

    // Extract just the skills section for updating existing files
    const skillsSectionContent = extractSkillsSection(content);

    // Handle AGENTS.md based on whether it exists (don't fail if this doesn't work)
    let agentsMdResult = { updated: false, created: false };
    if (agentsMdExists) {
        // Update existing AGENTS.md by inserting/updating skills section
        const result = updateAgentFile(agentsMdPath, skillsSectionContent);
        if (result.updated) {
            agentsMdResult = { ...result, updated: true };
            const agentsMdLocation = agentsMdPath === rootAgentsMdPath ? 'root' : '.agents/';
            console.log(`‚úì Updated AGENTS.md with skills section (${agentsMdLocation})`);
        } else if (result.error) {
            console.log('‚ö†Ô∏è  Failed to update AGENTS.md (continuing with other files)');
        }
    } else {
        // Create new AGENTS.md from full template (optional, don't fail if it doesn't work)
        try {
            writeFileSync(agentsMdPath, content, 'utf8');
            agentsMdResult = { updated: false, created: true };
            const agentsMdLocation = agentsMdPath === rootAgentsMdPath ? 'root' : '.agents/';
            console.log(`‚úì Created AGENTS.md from template (${agentsMdLocation})`);
        } catch (error) {
            console.log(`‚ö†Ô∏è  Could not create AGENTS.md: ${error.message} (continuing with other files)`);
        }
    }

    // Update CLAUDE.md if it exists (prefer root, then .agents/)
    const rootClaudeMdPath = join(projectRoot, 'CLAUDE.md');
    const dotAgentsClaudeMdPath = join(agentsDir, 'CLAUDE.md');
    const claudeMdPath = existsSync(rootClaudeMdPath) ? rootClaudeMdPath : dotAgentsClaudeMdPath;
    const claudeResult = updateAgentFile(claudeMdPath, skillsSectionContent);
    if (claudeResult.updated) {
        const claudeMdLocation = claudeMdPath === rootClaudeMdPath ? 'root' : '.agents/';
        console.log(`‚úì Updated CLAUDE.md (${claudeResult.type} detection, ${claudeMdLocation})`);
        if (claudeResult.backup) {
            console.log(`  Backed up to ${claudeResult.backup}`);
        }
    } else if (claudeResult.skipped) {
        console.log('‚ÑπÔ∏è  Skipped CLAUDE.md (does not exist)');
    } else if (claudeResult.error) {
        console.log('‚ö†Ô∏è  Failed to update CLAUDE.md');
    }

    // Update GEMINI.md if it exists (prefer root, then .agents/)
    const rootGeminiMdPath = join(projectRoot, 'GEMINI.md');
    const dotAgentsGeminiMdPath = join(agentsDir, 'GEMINI.md');
    const geminiMdPath = existsSync(rootGeminiMdPath) ? rootGeminiMdPath : dotAgentsGeminiMdPath;
    const geminiResult = updateAgentFile(geminiMdPath, skillsSectionContent);
    if (geminiResult.updated) {
        const geminiMdLocation = geminiMdPath === rootGeminiMdPath ? 'root' : '.agents/';
        console.log(`‚úì Updated GEMINI.md (${geminiResult.type} detection, ${geminiMdLocation})`);
        if (geminiResult.backup) {
            console.log(`  Backed up to ${geminiResult.backup}`);
        }
    } else if (geminiResult.skipped) {
        console.log('‚ÑπÔ∏è  Skipped GEMINI.md (does not exist)');
    } else if (geminiResult.error) {
        console.log('‚ö†Ô∏è  Failed to update GEMINI.md');
    }

    // Build dynamic success message based on what was updated
    let setupMessage = `\n# Setup complete!\n\nYour project now has:
  - .agents/ directory structure`;
    
    if (agentsMdResult.updated || agentsMdResult.created) {
        const action = agentsMdResult.created ? 'created with' : 'updated with';
        const location = agentsMdPath === rootAgentsMdPath ? 'in project root' : 'in .agents/';
        setupMessage += `\n  - AGENTS.md ${action} universal skills instructions (${location})`;
    }
    
    if (claudeResult.updated) {
        const location = claudeMdPath === rootClaudeMdPath ? 'root' : '.agents/';
        setupMessage += `\n  - CLAUDE.md updated with latest skills content (${location})`;
    }
    
    if (geminiResult.updated) {
        const location = geminiMdPath === rootGeminiMdPath ? 'root' : '.agents/';
        setupMessage += `\n  - GEMINI.md updated with latest skills content (${location})`;
    }
    
    setupMessage += '\n  - .agents/skills/ ready for project-specific skills\n';
    
    // Check if any files were actually updated
    const anyUpdated = agentsMdResult.updated || agentsMdResult.created || claudeResult.updated || geminiResult.updated;
    if (!anyUpdated) {
        setupMessage += '\n‚ö†Ô∏è  No agent configuration files were found or updated.\n   Consider creating AGENTS.md, CLAUDE.md, or GEMINI.md for your project.\n';
    }
    
    if (existsSync(`${agentsMdPath}.backup-${new Date().toISOString().split('T')[0]}`)) {
        setupMessage += '\nüí° Review the backup and new AGENTS.md to merge any custom content';
    }
    if (claudeResult.backup || geminiResult.backup) {
        setupMessage += '\nüí° Review backups to verify no custom content was lost';
    }
    if (existsSync(`${agentsMdPath}.backup-${new Date().toISOString().split('T')[0]}`) || claudeResult.backup || geminiResult.backup) {
        setupMessage += '\n';
    }
    console.log(setupMessage);
};

const runUpdate = (options = {}) => {
    const skipReinstall = options.skipReinstall || false;
    
    console.log('# Checking for Superpowers updates...\n');
    
    // 1. Check current state
    const updateInfo = checkForUpdates();
    
    if (updateInfo.error) {
        console.log('‚ö†Ô∏è  Could not check for updates (network issue)');
        return;
    }
    
    if (!updateInfo.hasUpdates) {
        console.log('‚úì Already up to date');
        return;
    }
    
    // 2. Safety check - is repo clean?
    if (updateInfo.hasLocalChanges) {
        console.log(`‚ö†Ô∏è  Cannot auto-update: local changes detected\n   Commit or stash your changes first, then run update again\n   Or manually update: cd ${paths.superpowersRepo} && git pull`);
        return;
    }
    
    // 3. Check if on main branch
    if (!isOnMainBranch()) {
        console.log(`‚ö†Ô∏è  Not on main branch, skipping auto-update\n   Switch to main branch first: cd ${paths.superpowersRepo} && git checkout main`);
        return;
    }
    
    // 4. Perform git pull
    console.log(`üì¶ Updating from ${updateInfo.currentCommit.substring(0,7)} to ${updateInfo.latestCommit.substring(0,7)}
   (${updateInfo.commitsBehind} new commit${updateInfo.commitsBehind > 1 ? 's' : ''})\n`);
    
    try {
        execSync('git pull origin main', { 
            cwd: paths.superpowersRepo, 
            stdio: 'pipe',
            timeout: 10000
        });
        console.log('‚úì Updated superpowers repository');
    } catch (error) {
        console.log(`‚úó Git pull failed: ${error.message}\n   Please resolve manually and try again`);
        return;
    }
    
    console.log('');
    
    // 5. Update config
    writeConfig({ 
        last_updated_commit: updateInfo.latestCommit,
        last_update_check: new Date().toISOString()
    });
    
    // 6. Determine what needs reinstalling
    if (skipReinstall) {
        console.log('‚ÑπÔ∏è  Skipping integration reinstall (--no-reinstall flag)\n\n‚úì Update complete!');
        return;
    }
    
    const integrationsToReinstall = determineReinstalls(updateInfo.changedFiles);
    
    if (integrationsToReinstall.length === 0) {
        console.log('‚ÑπÔ∏è  No integration files changed, skipping reinstalls\n\n‚úì Update complete!');
        return;
    }
    
    // 7. Reinstall affected integrations
    console.log('üîÑ Reinstalling updated integrations:\n');
    
    const results = [];
    for (const integration of integrationsToReinstall) {
        const result = reinstallIntegration(integration);
        results.push(result);
        if (result.success) {
            console.log(`  ‚úì ${integration}`);
        } else {
            console.log(`  ‚úó ${integration} (${result.error})`);
        }
    }
    
    console.log('');
    
    // 8. Reinstall aliases in case paths changed
    console.log('\n---\n');
    installAliases();
    
    // 9. Show summary
    const failures = results.filter(r => !r.success);
    if (failures.length > 0) {
        console.log('‚ö†Ô∏è  Update completed with errors:');
        for (const failure of failures) {
            console.log(`  - ${failure.integration} failed to install`);
            const commandName = `install-${failure.integration}`;
            console.log(`    Run manually: superpowers-agent ${commandName}`);
        }
    } else {
        console.log('‚úì Update complete!');
    }
};

const runBootstrap = () => {
    console.log('# Superpowers Bootstrap for Agents\n# ==================================\n');

    // Check for --no-update flag
    const noUpdate = process.argv.includes('--no-update');

    // Auto-update check
    if (!noUpdate) {
        const config = readConfig();
        const updateInfo = checkForUpdates();
        
        if (updateInfo.error) {
            console.log('## Update Check\n\n‚ö†Ô∏è  Could not check for updates (network issue)\n\n---\n');
        } else if (updateInfo.hasUpdates) {
            if (config.auto_update && !updateInfo.hasLocalChanges && isOnMainBranch()) {
                console.log('## Auto-Update\n');
                runUpdate();
                console.log('\n---\n');
            } else {
                console.log('## Update Available');
                console.log('');
                if (updateInfo.hasLocalChanges) {
                    console.log('‚ö†Ô∏è  Your superpowers installation is behind the latest version.\n    Cannot auto-update: local changes detected\n    To update, commit/stash changes then run: `superpowers-agent update`');
                } else if (!isOnMainBranch()) {
                    console.log('‚ö†Ô∏è  Your superpowers installation is behind the latest version.\n    Cannot auto-update: not on main branch\n    To update, switch to main then run: `superpowers-agent update`');
                } else {
                    console.log(`‚ö†Ô∏è  Your superpowers installation is behind the latest version.\n    To update, run: \`superpowers-agent update\`\n    Or enable auto-update: \`superpowers-agent config-set auto_update true\``);
                }
                console.log('\n---\n');
            }
        }
    }

    // Install universal aliases
    installAliases();
    console.log('---\n');

    // Install GitHub Copilot integration (always, it's IDE-based)
    console.log('## GitHub Copilot Integration\n');
    installCopilotPrompts();
    console.log('');
    installCopilotInstructions();
    console.log('\n---\n');

    // Install Cursor integration (always, it's IDE-based)
    console.log('## Cursor Integration\n');
    installCursorCommands();
    console.log('');
    installCursorHooks();
    console.log('\n---\n');

    // Install OpenAI Codex integration
    console.log('## OpenAI Codex Integration\n');
    const codexDetected = toolDetection.codex.check();
    if (codexDetected) {
        installCodexPrompts();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.codex.name} CLI not detected)\nüí° To enable Codex integration:\n   1. Install Codex: ${toolDetection.codex.installUrl}\n   2. Run: superpowers-agent ${toolDetection.codex.bootstrapCommand}`);
    }
    console.log('\n---\n');

    // Install Gemini integration
    console.log('## Gemini Integration\n');
    const geminiDetected = toolDetection.gemini.check();
    if (geminiDetected) {
        installGeminiCommands();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.gemini.name} CLI not detected)\nüí° To enable Gemini integration:\n   1. Install Gemini: ${toolDetection.gemini.installUrl}\n   2. Run: superpowers-agent ${toolDetection.gemini.bootstrapCommand}`);
    }
    console.log('\n---\n');

    // Install Claude Code integration
    console.log('## Claude Code Integration\n');
    const claudeDetected = toolDetection.claude.check();
    if (claudeDetected) {
        installClaudeCommands();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.claude.name} CLI not detected)\nüí° To enable Claude Code integration:\n   1. Install Claude Code: ${toolDetection.claude.installUrl}\n   2. Run: superpowers-agent ${toolDetection.claude.bootstrapCommand}`);
    }
    console.log('\n---\n');

    // Install opencode integration
    console.log('## opencode Integration\n');
    const opencodeDetected = toolDetection.opencode.check();
    if (opencodeDetected) {
        installOpencodeCommands();
    } else {
        console.log(`‚ö†Ô∏è  Skipped (${toolDetection.opencode.name} CLI not detected)\nüí° To enable OpenCode integration:\n   1. Install OpenCode: ${toolDetection.opencode.installUrl}\n   2. Run: superpowers-agent ${toolDetection.opencode.bootstrapCommand}`);
    }
    console.log('\n---\n');

    // Show bootstrap instructions
    if (existsSync(paths.bootstrap)) {
        console.log('## Bootstrap Instructions:\n');
        try {
            const content = readFileSync(paths.bootstrap, 'utf8');
            console.log(content);
        } catch (error) {
            console.log(`Error reading bootstrap file: ${error.message}`);
        }
        console.log('\n---\n');
    }

    // Show available skills
    console.log('## Available Skills:\n');
    runFindSkills();
    console.log('\n---\n');

    // Auto-load using-superpowers skill if it exists
    const usingSuperpowersPath = join(paths.homeSuperpowersSkills, 'using-superpowers', 'SKILL.md');
    if (existsSync(usingSuperpowersPath)) {
        console.log('## Auto-loading superpowers:using-superpowers skill:\n');
        runUseSkill('superpowers:using-superpowers');
        console.log('\n---\n');
    }

    console.log('# Bootstrap Complete!\n# You now have access to all skills.\n# Use ".agents/superpowers-agent use-skill <skill>" to load and apply skills.\n# Remember: If a skill applies to your task, you MUST use it!');
};

const parseSkillName = (skillName) => {
    if (skillName.startsWith('superpowers:')) {
        return { type: 'superpowers', path: skillName.substring(12).replace(/^skills\//, '') };
    }
    if (skillName.startsWith('claude:')) {
        return { type: 'claude', path: skillName.substring(7).replace(/^skills\//, '') };
    }
    return { type: null, path: skillName.replace(/^skills\//, '') };
};

const findSkillFile = (searchPath) => {
    const skillMdPath = join(searchPath, 'SKILL.md');
    if (existsSync(skillMdPath)) return skillMdPath;
    if (searchPath.endsWith('SKILL.md') && existsSync(searchPath)) return searchPath;
    return null;
};

const locateSkill = (skillName) => {
    const { type, path: actualSkillPath } = parseSkillName(skillName);
    
    // Map type to directory path
    const typeToDirMap = {
        'superpowers': paths.homeSuperpowersSkills,
        'claude': paths.projectClaudeSkills,
        'project': paths.projectAgentsSkills,
        'personal': paths.homePersonalSkills
    };
    
    // Search order configuration
    const searchOrder = type 
        ? [{ type, dir: typeToDirMap[type] }]
        : [
            { type: 'project', dir: paths.projectAgentsSkills },
            { type: 'claude', dir: paths.projectClaudeSkills },
            { type: 'personal', dir: paths.homePersonalSkills },
            { type: 'superpowers', dir: paths.homeSuperpowersSkills }
          ];

    for (const { type: sourceType, dir } of searchOrder) {
        const skillPath = join(dir, actualSkillPath);
        const skillFile = findSkillFile(skillPath);
        if (skillFile) {
            return { skillFile, sourceType, actualSkillPath };
        }
    }

    return null;
};

const extractSkillContent = (skillFile) => {
    try {
        const fullContent = readFileSync(skillFile, 'utf8');
        const frontmatter = extractFrontmatter(skillFile);
        
        const lines = fullContent.split('\n');
        let inFrontmatter = false;
        let frontmatterEnded = false;
        const contentLines = [];

        for (const line of lines) {
            if (line.trim() === '---') {
                if (inFrontmatter) {
                    frontmatterEnded = true;
                    continue;
                }
                inFrontmatter = true;
                continue;
            }

            if (frontmatterEnded || !inFrontmatter) {
                contentLines.push(line);
            }
        }

        return {
            content: contentLines.join('\n').trim(),
            frontmatter
        };
    } catch (error) {
        throw new Error(`Error reading skill file: ${error.message}`);
    }
};

const runUseSkill = (skillName) => {
    if (!skillName) {
        console.log(`Usage: .agents/superpowers-agent use-skill <skill-name>\nExamples:\n  .agents/superpowers-agent use-skill superpowers:brainstorming  # Load superpowers skill\n  .agents/superpowers-agent use-skill claude:persistent-planning # Load claude skill\n  .agents/superpowers-agent use-skill brainstorming              # Load project/personal skill\n  .agents/superpowers-agent use-skill my-custom-skill            # Load project skill`);
        return;
    }

    const location = locateSkill(skillName);
    
    if (!location) {
        console.log(`Error: Skill not found: ${skillName}\n\nAvailable skills:`);
        runFindSkills();
        return;
    }

    const { skillFile, sourceType, actualSkillPath } = location;
    
    try {
        const { content, frontmatter } = extractSkillContent(skillFile);
        const displayName = skillTypes[sourceType].prefix + actualSkillPath;
        const skillDirectory = dirname(skillFile);

        // Display skill header
        let header = `# ${frontmatter.name || displayName}`;
        if (frontmatter.description) header += `\n# ${frontmatter.description}`;
        if (frontmatter.whenToUse) header += `\n# When to use: ${frontmatter.whenToUse}`;
        header += `\n# Supporting tools and docs are in ${skillDirectory}\n# ============================================\n\n${content}`;
        console.log(header);
    } catch (error) {
        console.log(error.message);
    }
};

const updateReadmeWithAutoUpdateDocs = () => {
    const readmePath = join(paths.superpowersRepo, 'README.md');
    
    if (!existsSync(readmePath)) {
        console.log('‚ö†Ô∏è  README.md not found');
        return;
    }
    
    const content = readFileSync(readmePath, 'utf8');
    
    // Find the "## Updating" section
    const updatingMatch = content.match(/^## Updating$/m);
    
    if (!updatingMatch) {
        console.log('‚ö†Ô∏è  Could not find "## Updating" section in README.md');
        return;
    }
    
    // Find section boundaries
    const sectionStart = updatingMatch.index + updatingMatch[0].length;
    const afterSection = content.substring(sectionStart);
    const nextSectionMatch = afterSection.match(/^## /m);
    const sectionEnd = nextSectionMatch 
        ? sectionStart + nextSectionMatch.index 
        : content.length;
    
    // Build new section content
    const newSectionContent = `

### Automatic Updates (Default)

Superpowers automatically checks for and applies updates during bootstrap by default:

\`\`\`bash
superpowers-agent bootstrap
\`\`\`

**Auto-update behavior:**
- ‚úì Fetches latest changes from GitHub main branch
- ‚úì Only updates if repository is clean (no local modifications)
- ‚úì Intelligently reinstalls only changed integrations (cursor, copilot, etc.)
- ‚úì Skips update if not on main branch or network unavailable

**Skip auto-update for a single run:**
\`\`\`bash
superpowers-agent bootstrap --no-update
\`\`\`

### Manual Updates

Update anytime with the dedicated update command:

\`\`\`bash
superpowers-agent update
\`\`\`

This command:
- Pulls latest changes from GitHub
- Detects which integration files changed
- Reinstalls only affected integrations
- Shows summary of what was updated

**Update without reinstalling integrations:**
\`\`\`bash
superpowers-agent update --no-reinstall
\`\`\`

### Configuration

**Disable auto-update permanently:**
\`\`\`bash
superpowers-agent config-set auto_update false
\`\`\`

When disabled, bootstrap will show an "Update Available" message instead of auto-updating.

**Re-enable auto-update:**
\`\`\`bash
superpowers-agent config-set auto_update true
\`\`\`

**View current configuration:**
\`\`\`bash
superpowers-agent config-get
\`\`\`

Configuration is stored in \`~/.agents/superpowers/.config.json\` and persists across updates.

### Claude Code Plugin

For Claude Code plugin users:
\`\`\`bash
/plugin update superpowers
\`\`\`

`;
    
    // Replace section
    const newContent = content.substring(0, sectionStart) + 
                       newSectionContent + 
                       content.substring(sectionEnd);
    
    // Backup
    const timestamp = new Date().toISOString().split('T')[0];
    const backupPath = `${readmePath}.backup-${timestamp}`;
    try {
        execSync(`cp "${readmePath}" "${backupPath}"`, { stdio: 'pipe' });
    } catch (error) {
        console.log(`‚ö†Ô∏è  Could not create backup: ${error.message}`);
        return;
    }
    
    // Write
    try {
        writeFileSync(readmePath, newContent, 'utf8');
    } catch (error) {
        console.log(`‚úó Failed to write README.md: ${error.message}`);
        return;
    }
    
    console.log('‚úì Updated README.md with auto-update documentation');
    console.log(`  Backed up to ${parse(backupPath).base}`);
    console.log('  See "## Updating" section for new auto-update details');
};

// ============================================================================
// ALIAS INSTALLATION FUNCTIONS
// ============================================================================

const detectShellProfile = (shell, home) => {
    // 1. Check for user override
    if (process.env.PROFILE === '/dev/null') {
        return null; // User opted out
    }
    
    if (process.env.PROFILE && existsSync(process.env.PROFILE)) {
        return process.env.PROFILE;
    }
    
    // 2. Shell-specific detection
    if (shell === 'bash') {
        const bashrc = join(home, '.bashrc');
        const bashProfile = join(home, '.bash_profile');
        if (existsSync(bashrc)) return bashrc;
        if (existsSync(bashProfile)) return bashProfile;
    }
    
    if (shell === 'zsh') {
        const zshrc = join(home, '.zshrc');
        const zprofile = join(home, '.zprofile');
        if (existsSync(zshrc)) return zshrc;
        if (existsSync(zprofile)) return zprofile;
    }
    
    if (shell === 'fish') {
        const fishConfig = join(home, '.config', 'fish', 'config.fish');
        if (existsSync(fishConfig)) return fishConfig;
        // Return path anyway, we'll create it
        return fishConfig;
    }
    
    // 3. Fallback chain
    const fallbacks = ['.profile', '.bashrc', '.bash_profile', '.zshrc'];
    for (const file of fallbacks) {
        const fullPath = join(home, file);
        if (existsSync(fullPath)) return fullPath;
    }
    
    // 4. Default to .profile (will be created)
    return join(home, '.profile');
};

const installViaRCFile = (binDir = null) => {
    const home = homedir();
    const shell = (process.env.SHELL || '').split('/').pop();
    
    // Detect RC file
    const profileFile = detectShellProfile(shell, home);
    
    if (!profileFile) {
        console.log('‚ö†Ô∏è  Could not detect shell configuration file.\n');
        console.log('Please add manually to your shell RC file:\n');
        if (binDir) {
            console.log(`  export PATH="${binDir}:$PATH"\n`);
        } else {
            console.log(`  export PATH="$HOME/.agents/superpowers/.agents:$PATH"\n`);
        }
        return { success: false, method: 'manual' };
    }
    
    // Check if already installed
    try {
        const content = readFileSync(profileFile, 'utf8');
        if (content.includes('superpowers')) {
            console.log(`‚úÖ Aliases already configured in ${profileFile}\n`);
            return { success: true, method: 'rc-existing' };
        }
    } catch (err) {
        // File doesn't exist, will create
    }
    
    // Determine content to append based on shell
    const pathToAdd = binDir || '$HOME/.agents/superpowers/.agents';
    let content;
    
    if (shell === 'fish') {
        content = `\n# Added by Superpowers\nfish_add_path ${pathToAdd}\n`;
    } else {
        // bash, zsh, or generic
        content = `\n# Added by Superpowers\nexport PATH="${pathToAdd}:$PATH"\n`;
    }
    
    // Append to RC file
    try {
        const dir = dirname(profileFile);
        if (!existsSync(dir)) {
            execSync(`mkdir -p "${dir}"`, { stdio: 'pipe' });
        }
        
        // Append content
        const existingContent = existsSync(profileFile) ? readFileSync(profileFile, 'utf8') : '';
        writeFileSync(profileFile, existingContent + content, 'utf8');
        
        console.log(`‚úÖ Aliases configured in ${profileFile}\n`);
        console.log('To use immediately, run:\n');
        console.log(`  source ${profileFile}\n`);
        console.log('Or restart your terminal.\n');
        
        return { success: true, method: 'rc-file', file: profileFile };
    } catch (err) {
        console.log(`‚ö†Ô∏è  Could not write to ${profileFile}: ${err.message}\n`);
        console.log('Please add manually:\n');
        console.log(content);
        return { success: false, method: 'manual' };
    }
};

const installUnixAliases = () => {
    const home = homedir();
    const target = join(home, '.agents', 'superpowers', '.agents', 'superpowers-agent');
    
    // Verify target exists
    if (!existsSync(target)) {
        console.log('‚ö†Ô∏è  Superpowers not installed. Run bootstrap first.\n');
        return { success: false, method: 'not-installed' };
    }
    
    // ATTEMPT 1: /usr/local/bin
    try {
        const binDir = '/usr/local/bin';
        if (existsSync(binDir)) {
            execSync(`ln -sf "${target}" "${binDir}/superpowers"`, { stdio: 'pipe' });
            execSync(`ln -sf "${target}" "${binDir}/superpowers-agent"`, { stdio: 'pipe' });
            console.log('‚úÖ Aliases installed via symlink in /usr/local/bin\n');
            console.log('Test with: superpowers find-skills\n');
            return { success: true, method: 'symlink-system' };
        }
    } catch (err) {
        // Permission denied or directory doesn't exist, try next method
    }
    
    // ATTEMPT 2: ~/.local/bin
    try {
        const binDir = join(home, '.local', 'bin');
        execSync(`mkdir -p "${binDir}"`, { stdio: 'pipe' });
        execSync(`ln -sf "${target}" "${binDir}/superpowers"`, { stdio: 'pipe' });
        execSync(`ln -sf "${target}" "${binDir}/superpowers-agent"`, { stdio: 'pipe' });
        
        // Check if ~/.local/bin is in PATH
        const pathDirs = process.env.PATH.split(':');
        if (pathDirs.includes(binDir)) {
            console.log('‚úÖ Aliases installed via symlink in ~/.local/bin\n');
            console.log('Test with: superpowers find-skills\n');
            return { success: true, method: 'symlink-user' };
        } else {
            // Need to add to PATH via RC file
            console.log('‚úÖ Symlinks created in ~/.local/bin\n');
            console.log('Adding ~/.local/bin to PATH...\n');
            return installViaRCFile(binDir);
        }
    } catch (err) {
        // Symlink failed, fall back to RC file
        console.log('‚ö†Ô∏è  Could not create symlinks, using RC file method...\n');
        return installViaRCFile(null);
    }
};

const installWindowsAliases = () => {
    const home = homedir();
    const binDir = join(home, '.agents', 'bin');
    const target = join(home, '.agents', 'superpowers', '.agents', 'superpowers-agent');
    
    // Verify target exists
    if (!existsSync(target)) {
        console.log('‚ö†Ô∏è  Superpowers not installed. Run bootstrap first.\n');
        return { success: false, method: 'not-installed' };
    }
    
    // Create bin directory
    try {
        if (!existsSync(binDir)) {
            execSync(`mkdir "${binDir}"`, { stdio: 'pipe' });
        }
    } catch (err) {
        console.log(`‚ö†Ô∏è  Could not create bin directory: ${err.message}\n`);
        return { success: false, method: 'failed' };
    }
    
    // Create batch file wrappers
    const batchContent = `@echo off\nnode "${target}" %*\n`;
    
    try {
        writeFileSync(join(binDir, 'superpowers.bat'), batchContent);
        writeFileSync(join(binDir, 'superpowers-agent.bat'), batchContent);
        console.log('‚úÖ Batch file wrappers created\n');
    } catch (err) {
        console.log(`‚ö†Ô∏è  Could not create batch files: ${err.message}\n`);
        return { success: false, method: 'failed' };
    }
    
    // Check if bin directory is in PATH
    const pathDirs = process.env.PATH.split(';');
    const binDirNormalized = binDir.toLowerCase();
    const inPath = pathDirs.some(dir => dir.toLowerCase() === binDirNormalized);
    
    if (inPath) {
        console.log('‚úÖ Aliases ready (bin directory already in PATH)\n');
        console.log('Test with: superpowers find-skills\n');
        return { success: true, method: 'windows-existing-path' };
    }
    
    // Add to PATH
    try {
        execSync(`setx PATH "%PATH%;${binDir}"`, { stdio: 'pipe' });
        console.log('‚úÖ Added to PATH\n');
        console.log('Please restart your terminal to use the aliases.\n');
        console.log('Test with: superpowers find-skills\n');
        return { success: true, method: 'windows-path-added' };
    } catch (err) {
        console.log('‚ö†Ô∏è  Could not automatically add to PATH.\n');
        console.log('Please add manually:\n');
        console.log(`  1. Open System Properties > Environment Variables\n`);
        console.log(`  2. Edit user PATH variable\n`);
        console.log(`  3. Add: ${binDir}\n`);
        return { success: false, method: 'manual' };
    }
};

const installAliases = () => {
    const plat = platform();
    
    console.log('## Installing Universal Aliases\n');
    
    if (plat === 'win32') {
        return installWindowsAliases();
    } else {
        return installUnixAliases();
    }
};

// ============================================================================
// CONFIG MANAGEMENT
// ============================================================================

const runConfigGet = () => {
    const config = readConfig();
    console.log('Current configuration:');
    console.log(JSON.stringify(config, null, 2));
};

const runConfigSet = () => {
    const key = process.argv[3];
    const value = process.argv[4];
    
    if (!key || value === undefined) {
        console.log(`Usage: .agents/superpowers-agent config-set <key> <value>

Available keys:
  auto_update (true/false) - Enable/disable automatic updates during bootstrap

Examples:
  .agents/superpowers-agent config-set auto_update false
  .agents/superpowers-agent config-set auto_update true`);
        return;
    }
    
    // Parse boolean strings
    let parsedValue = value;
    if (value === 'true') parsedValue = true;
    else if (value === 'false') parsedValue = false;
    
    const updates = {};
    updates[key] = parsedValue;
    writeConfig(updates);
    
    console.log(`‚úì Set ${key} = ${parsedValue}`);
};

// Command dispatcher
const commands = {
    bootstrap: runBootstrap,
    update: () => {
        const skipReinstall = process.argv.includes('--no-reinstall');
        runUpdate({ skipReinstall });
    },
    'config-get': runConfigGet,
    'config-set': runConfigSet,
    'setup-skills': runSetupSkills,
    'use-skill': () => runUseSkill(process.argv[3]),
    'find-skills': runFindSkills,
    'install-copilot-prompts': installCopilotPrompts,
    'install-copilot-instructions': installCopilotInstructions,
    'install-cursor-commands': installCursorCommands,
    'install-cursor-hooks': installCursorHooks,
    'install-codex-prompts': installCodexPrompts,
    'install-gemini-commands': installGeminiCommands,
    'install-claude-commands': installClaudeCommands,
    'install-opencode-commands': installOpencodeCommands,
    'install-aliases': installAliases,
    default: () => {
        console.log(`Superpowers for Agents
Usage:
  .agents/superpowers-agent bootstrap [--no-update]        # Run complete bootstrap with all skills
  .agents/superpowers-agent update [--no-reinstall]        # Update to latest version from GitHub
  .agents/superpowers-agent config-get                     # Show current configuration
  .agents/superpowers-agent config-set <key> <value>       # Update configuration
  .agents/superpowers-agent setup-skills                   # Initialize project with skills documentation
  .agents/superpowers-agent use-skill <skill-name>         # Load a specific skill
  .agents/superpowers-agent find-skills                    # List all available skills
  .agents/superpowers-agent install-copilot-prompts        # Install GitHub Copilot prompts only
  .agents/superpowers-agent install-copilot-instructions   # Install universal instructions only
  .agents/superpowers-agent install-cursor-commands        # Install Cursor commands only
  .agents/superpowers-agent install-cursor-hooks           # Install Cursor hooks only
  .agents/superpowers-agent install-codex-prompts          # Install OpenAI Codex prompts only
  .agents/superpowers-agent install-gemini-commands        # Install Gemini commands only
  .agents/superpowers-agent install-claude-commands        # Install Claude Code commands only
  .agents/superpowers-agent install-opencode-commands      # Install opencode commands only
  .agents/superpowers-agent install-aliases                # Install universal aliases (superpowers, superpowers-agent)

Examples:
  .agents/superpowers-agent bootstrap                      # Auto-update then bootstrap
  .agents/superpowers-agent bootstrap --no-update          # Skip update, just bootstrap
  .agents/superpowers-agent update                         # Update and reinstall changed integrations
  .agents/superpowers-agent config-set auto_update false   # Disable auto-update
  .agents/superpowers-agent use-skill superpowers:brainstorming
  .agents/superpowers-agent use-skill claude:persistent-planning
  .agents/superpowers-agent use-skill my-custom-skill`);
    }
};

// Main execution
const command = process.argv[2];
const handler = commands[command] || commands.default;
handler();
